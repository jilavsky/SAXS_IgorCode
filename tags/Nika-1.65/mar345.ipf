#pragma rtGlobals=1		// Use modern global access method.Menu "Load Waves"	"Load MAR345 Image…", DoReadMAR345("", "") 	help = {"Load a MAR345 image plate file into the current datafolder"}EndFunction DoReadMAR345(theFilename, inWaveName)	String	theFilename	String inWaveName		Variable	marFile		String		savedDF = GetDataFolder(1)	NewDataFolder/O/S root:Packages	NewDataFolder/O/S root:Packages:MAR345  	if ( strlen(theFilename) == 0 )		Open/D/T="????"/R/M="Select a MAR345 image" marFile		theFilename = S_filename	endif	Open/R/Z marFile as theFilename	switch(V_flag)		case 0:			// OK			break		case -1:			// Cancel			return	0		default:				Abort "Error opening file " + theFilename + ": " + num2str(V_flag) + ".\rCheck the file name."	endswitch		Make/O/N=9	headerData		SetDimLabel 0, 0, nx, headerData	SetDimLabel 0, 1, ny, headerData	SetDimLabel 0, 2, overflows, headerData	SetDimLabel 0, 3, pixelx, headerData	SetDimLabel 0, 4, pixely, headerData	SetDimLabel 0, 5, wavelength, headerData	SetDimLabel 0, 6, distance, headerData	SetDimLabel 0, 7, phi, headerData	SetDimLabel 0, 8, oscillationRange, headerData			ReadMAR345_Header(marFile, headerData)	ReadMAR345_Data(marFile, theFilename, headerData, savedDF, inWaveName)		KillWaves headerData	Close marFile		SetDataFolder savedDFEndFunction ReadMAR345_Header(marFile, headerData)	Variable	marFile	Wave		headerData		Make/O/I/N=16 rawHeader		SetDimLabel 0, 0, BOM, rawHeader	SetDimLabel 0, 1, nPixels, rawHeader	SetDimLabel 0, 2, overflows, rawHeader		SetDimLabel 0, 6, pixelx, rawHeader	SetDimLabel 0, 7, pixely, rawHeader	SetDimLabel 0, 8, wavelength, rawHeader	SetDimLabel 0, 9, distance, rawHeader	SetDimLabel 0, 10, phi1, rawHeader	SetDimLabel 0, 11, phi2, rawHeader		FBinRead/B=3/F=3 marFile, rawHeader	if (rawHeader[%BOM] != 1234)		// byte-order marker		Abort "Badly formatted file."	endif			// nx = ny 	headerData[%nx] = rawHeader[%nPixels]	headerData[%ny] = rawHeader[%nPixels]		headerData[%overflows] = rawHeader[%overflows]		// pixel size	if (rawHeader[%pixelx] <= 0)		rawHeader[%pixelx] = rawHeader[%pixely]	endif	if (rawHeader[%pixely] <= 0)		rawHeader[%pixely] = rawHeader[%pixelx]	endif	headerData[%pixelx] = rawHeader[%pixelx] / 1e3	headerData[%pixely] = rawHeader[%pixely] / 1e3		headerData[%wavelength] = rawHeader[%wavelength] / 1e6	headerData[%distance] = rawHeader[%distance] / 1e3	headerData[%phi] = rawHeader[%phi1] / 1e3	headerData[%oscillationRange] = (rawHeader[%phi2] - rawHeader[%phi1]) / 1e3		KillWaves rawHeader		// skip remainder of header	FSetPos marFile, 4096EndFunction ReadMAR345_Data(marFile, theFilename, headerData, inDF, inWaveName)	Variable	marFile	String		theFilename	Wave		headerData	String		inDF	String		inWaveName	Make/O/I/N=(2*headerData[%overflows]) mar345overflow	FBinRead/B=3/F=3 marFile, mar345overflow		Variable nx, ny	Variable PACK = 2	do		String	str		FReadLine marFile, str		sscanf str, "CCP4 packed image, X: %04d, Y: %04d", nx, ny		if (V_flag == 2) 			PACK = 1			break		endif		sscanf str, "CCP4 packed image V%d, X: %04d, Y: %04d", PACK, nx, ny		if (V_flag == 3) 			break		endif	while (1)		if (PACK > 1)		KillWaves mar345			if (headerData[%overflows] > 0)			KillWaves mar345overflow		endif		Abort "Bad image format"	endif		FStatus marFile	Make/B/O/N=(V_logEOF - V_filePos) raw	FBinRead/F=1 marFile, raw		if (cmpstr(inWaveName, "") == 0)		inWaveName = ParseFilePath(0, theFilename, ":", 1, 0)	endif	ccp4unpack/O /V=mar345overflow nx, ny, raw as $(inDF + inWaveName)		KillWaves mar345overflow	KillWaves rawEndFunction ReadMAR345_Data_NEWER(marFile, theFilename, headerData)	Variable	marFile	String		theFilename	Wave		headerData	Variable pixels = headerData[%nx] * headerData[%ny]		Make/O/W/N=(pixels) $"TEST"	Wave mar345 = $"TEST"		if (headerData[%overflows] > 0)		Make/O/I/N=(2*headerData[%overflows]) $("TEST_over")		Wave mar345_over = $("TEST_over")		FBinRead/B=3/F=3 marFile, mar345_over	endif		Variable nx, ny	Variable PACK = 2	do		String	str		FReadLine marFile, str		sscanf str, "CCP4 packed image, X: %04d, Y: %04d", nx, ny		if (V_flag == 2) 			PACK = 1			break		endif		sscanf str, "CCP4 packed image V%d, X: %04d, Y: %04d", PACK, nx, ny		if (V_flag == 3) 			break		endif	while (1)		if (PACK > 1)		KillWaves mar345			if (headerData[%overflows] > 0)			KillWaves mar345_over		endif		Abort "Bad image format"	endif		Make/I/U/O/N=2 register	SetDimLabel 0, 0, in, register	SetDimLabel 0, 1, next, register	register[%in] = 0	Variable inCount = 0	Variable get = 6	Variable init = 1		nx = headerData[%nx]		Variable n = 0	Variable nRaw = 0	FStatus marFile	Make/B/U/O/N=(V_logEOF - V_filePos) raw	FBinRead/U/F=1 marFile, raw				//	Make/I/U/O bitshift = {1,2,4,8,16,32,64,128,256,512,1024,2048}	Make/I/U/O/N=32 bitshift = 2^x	Make/B/U/O decode = { 0, 4, 5, 6, 7, 8, 16, 32 }		Variable pixel	for (pixel = 0; pixel < pixels;)		register[%next] = 0		Variable need = get		for (;need;)			if (inCount == 0)//				FBinRead/U/F=1 marFile, in							register[%in] = raw[nRaw]				nRaw += 1				inCount = 8			endif			if (need > inCount)//				next = next | (in * bitshift[get - need])				register[%next] = register[%next] | shiftLeft(register[%in], get - need)				need -= inCount				register[%in] = 0				inCount = 0			else//				next = next | ((in & (bitshift[need] - 1)) * bitshift[get - need])//				in = (in / bitshift[need]) & 0xFF				register[%next] = register[%next] | shiftLeft(register[%in] & (bitshift[need] - 1), get - need)				register[%in] = shiftRight(register[%in], need) // & 0xFF				inCount -= need				break			endif		endfor				Variable pixCount		// Decode bits 0-5		if (init)			pixCount = bitshift[register[%next] & 7]			get = decode[shiftRight(register[%next], 3) & 7]			init = 0		else			// Decode a pixel			// Sign-extend?			if (get)				register[%next] = register[%next] | -(register[%next] & bitshift[get - 1])			endif		//			if (get && next & bitshift[get - 1] != 0)//				next -= bitshift[get]//				next *= -1//			endif								// Calculate the final pixel valuemar345[n] = register[%next] & 0x0FFFF		if (0)			if (pixel > nx)				Variable A, B, C, D									A = mar345[n - 1 - nx]				B = mar345[n     - nx]				C = mar345[n + 1 - nx]				D = mar345[n - 1     ]				//				Variable stuff = A + B + C + D				Variable stuff = (A & 0x07FFF) + (B & 0x07FFF) + (C & 0x07FFF) + (D & 0x07FFF)				stuff -= (A & 0x08000) + (B & 0x08000) + (C & 0x08000) + (D & 0x08000)				mar345[n] = (register[%next] + (stuff + 2) / 4) & 0x0FFFF			elseif (pixel)				mar345[n] = mar345[n - 1] + register[%next] & 0x0FFFF			else				mar345[n] = register[%next] & 0x0FFFF			endif		endif						pixel += 1			n += 1			pixCount -= 1						// New set?			if (pixCount == 0)				init = 1				get = 6			endif					endif		endfor		Redimension/N=(headerData[%nx],headerData[%ny]) mar345EndFunction ReadMAR345_Data_NEW(marFile, theFilename, headerData)	Variable	marFile	String		theFilename	Wave		headerData	Variable pixels = headerData[%nx] * headerData[%ny]		Make/O/W/N=(pixels) $"TEST"	Wave mar345 = $"TEST"		if (headerData[%overflows] > 0)		Make/O/I/N=(2*headerData[%overflows]) $("TEST_over")		Wave mar345_over = $("TEST_over")		FBinRead/B=3/F=3 marFile, mar345_over	endif		Variable nx, ny	Variable PACK = 2	do		String	str		FReadLine marFile, str		sscanf str, "CCP4 packed image, X: %04d, Y: %04d", nx, ny		if (V_flag == 2) 			PACK = 1			break		endif		sscanf str, "CCP4 packed image V%d, X: %04d, Y: %04d", PACK, nx, ny		if (V_flag == 3) 			break		endif	while (1)		if (PACK > 1)		KillWaves mar345			if (headerData[%overflows] > 0)			KillWaves mar345_over		endif		Abort "Bad image format"	endif		nx = headerData[%nx]		FStatus marFile	Make/B/U/O/N=(V_logEOF - V_filePos) raw	FBinRead/U/F=1 marFile, raw					Make/B/U/O bitshift = {1,2,4,8,16,32,64,128,256}	Make/B/U/O decode = { 0, 4, 5, 6, 7, 8, 16, 32 }	Make/I/O/N=33  setbits	setbits[ 0] = 0x00000000	setbits[ 1] = 0x00000001	setbits[ 2] = 0x00000003	setbits[ 3] = 0x00000007	setbits[ 4] = 0x0000000F	setbits[ 5] = 0x0000001F	setbits[ 6] = 0x0000003F	setbits[ 7] = 0x0000007F	setbits[ 8] = 0x000000FF	setbits[ 9] = 0x000001FF	setbits[10] = 0x000003FF	setbits[11] = 0x000007FF	setbits[12] = 0x00000FFF	setbits[13] = 0x00001FFF	setbits[14] = 0x00003FFF	setbits[15] = 0x00007FFF	setbits[16] = 0x0000FFFF	setbits[17] = 0x0001FFFF	setbits[18] = 0x0003FFFF	setbits[19] = 0x0007FFFF	setbits[20] = 0x000FFFFF	setbits[21] = 0x001FFFFF	setbits[22] = 0x003FFFFF	setbits[23] = 0x007FFFFF	setbits[24] = 0x00FFFFFF	setbits[25] = 0x01FFFFFF	setbits[26] = 0x03FFFFFF	setbits[27] = 0x07FFFFFF	setbits[28] = 0x0FFFFFFF	setbits[29] = 0x1FFFFFFF	setbits[30] = 0x3FFFFFFF	setbits[31] = 0x7FFFFFFF	setbits[32] = 0xFFFFFFFF		Variable	valids = 0	Variable	spillbits = 0	Variable	bitwindow = 0	Variable	spill = 0	Variable	nRaw = 0		Variable pixel	for (pixel = 0; pixel < pixels;)		if (valids < 6)			if (spillbits > 0)				bitwindow = bitwindow | shiftLeft(spill, valids)				valids += spillbits				spillbits = 0			else				spill = raw[nRaw]				nRaw += 1				spillbits = 8			endif		else			Variable	pixnum = bitshift[bitwindow & setbits[3]]			Variable	bitnum						bitwindow = shiftRight(bitwindow,3)			bitnum = decode[bitwindow & setbits[3]]			bitwindow = shiftRight(bitwindow,3)			valids -= 6			for (;(pixnum > 0) && (pixel < pixels);)				if (valids < bitnum)					if (spillbits > 0)						bitwindow = bitwindow | shiftLeft(spill, valids)						if ((32 - valids) > spillbits)							valids += spillbits							spillbits = 0						else							Variable	usedbits = 32 - valids							spill = shiftRight(spill, usedbits)							spillbits -= usedbits							valids = 32						endif					else						spill = raw[nRaw]						nRaw += 1						spillbits = 8					endif				else					Variable	nextint										pixnum -= 1					if (bitnum == 0)						nextint = 0					else						nextint = bitwindow & setbits[bitnum]						valids -= bitnum						bitwindow = shiftRight(bitwindow, bitnum)						if ((nextint & bitshift[bitnum - 1]) != 0)						// flip sign//							nextint = nextint | ~setbits[bitnum]							nextint -= bitshift[bitnum]						endif					endif					if (pixel > nx)						mar345[pixel] = nextint + (mar345[pixel-1] + mar345[pixel-x+1] + mar345[pixel-x] + mar345[pixel-x-1] + 2) / 4					elseif (pixel != 0)						mar345[pixel] = mar345[pixel-1] + nextint					else						mar345[pixel] = nextint					endif					pixel += 1				endif			endfor		endif	endfor		Redimension/N=(headerData[%nx],headerData[%ny]) mar345EndFunction shiftLeft(value, bits)	Variable	value	Variable	bits		Wave	bitshift	Wave	setbits//	return (value & setbits[32 - bits]) * bitshift[bits]	return (value * bitshift[bits]) & setbits[32 - bits]EndFunction shiftRight(value, bits)	Variable	value	Variable	bits		Wave	bitshift	Wave	setbits//	return trunc(value / bitshift[bits]) & setbits[32 - bits]	return trunc(value / bitshift[bits])End