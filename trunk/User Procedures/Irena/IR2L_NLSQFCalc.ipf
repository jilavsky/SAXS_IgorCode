#pragma rtGlobals=1		// Use modern global access method.
#pragma version=1.13

//*************************************************************************\
//* Copyright (c) 2005 - 2014, Argonne National Laboratory
//* This file is distributed subject to a Software License Agreement found
//* in the file LICENSE that is included with this distribution. 
//*************************************************************************/

//1.13 minor fixes for existence of Size distribution graphs so we do tno get errors. 
//1.12 removed most Executes in preparation for Igor 7
//1.11  bug fixes and modifications to Other graph outputs - colorization etc. 
//1.10 added checkboxes for displaying Size distributions, Residuals and IQ4 vs Q graphs and code shupporting it. 
//1.09 added checkboxes for displaying Size distributions, Residuals and IQ4 vs Q graphs and code shupporting it. 
//1.08 added to Unified fit ability to calculate B from G/Rg/P based on Guinier/Porod model. 
//1.07 fix to catch error for peak FWHM when data raneg is not good enough to calculate
//1.06 added Janus CoreShell Micelle
//1.05 fixed problem with calculations of peak positions
//1.04 changed min size used by the tool to 1A. Lot of users seems to be using this at really high qs... 
//1.03 Add Diffraction peak and Unified level as Populations, increase number of populations to 10
//1.02 added Unified level as Form factor
//1.01 added license for ANL


//calculations for Least square fit 2

////To calculate intensity we need to do following:
//	1. Calcualte for all used populations the distributions
//	2. Calculate for all used data sets the intensity generated by each population
//	3. Sum the intensities of all used populations for each used data set 
//	4. Display, calculate residuals etc.
//	  

//**********************************************************************************
//**********************************************************************************
//**********************************************************************************
//**********************************************************************************
//**********************************************************************************

Function IR2L_RecalculateIfSelected()

	NVAR RecalculateAutomatically=root:Packages:IR2L_NLSQF:RecalculateAutomatically
	string topWinNm=WinName(0,64) 
	if(RecalculateAutomatically)
		IR2L_CalculateIntensity(0,0)
	endif
	DoWIndow/F $(topWinNm)
end

//**********************************************************************************
//**********************************************************************************
//**********************************************************************************
//**********************************************************************************
//**********************************************************************************

Function IR2L_CalculateIntensity(skipCreateDistWvs, fitting) //Calculate distribution waves and distributions for all used population populations and all data sets...
	variable skipCreateDistWvs, fitting  	//set to 1 if skip changing the Radius/Diameter waves.. Use when using "semiAuto"
	//set fitting = 1 to skip some of the stuff to speed up fitting
	//find which pops and data sets are used
	variable pop, dataSet, i, j 
	//here we calculate intensity for all used populations and used datasets
	IR2L_PrepareSetsQvectors()		//this will handle all needed changes to Q vector to manage smearing...
	//now we have Q vector which is used to calculate 
	for(i=1;i<11;i+=1)
		NVAR Use=$("root:Packages:IR2L_NLSQF:UseThePop_pop"+num2str(i))
		SVAR FormFactor=$("root:Packages:IR2L_NLSQF:FormFactor_pop"+num2str(i))
		SVAR Model=$("root:Packages:IR2L_NLSQF:Model_pop"+num2str(i))
		if(Use)
			if(stringMatch(Model,"Size dist."))	//old code
				//first create waves for Distributions
				wave/Z Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
				wave/Z Diameter=$("root:Packages:IR2L_NLSQF:Diameter_Pop"+num2str(i))
				wave/Z NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
				wave/Z VolumeDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
				if(!skipCreateDistWvs || WaveExists(Radius)  || WaveExists(Diameter) ||  WaveExists(NumDist) || WaveExists(VolumeDist))
					IR2L_CreateDistributionWaves(i)
				endif
				//next we calculate the distributions (Guass, Log-Normal or LSW)
				wave NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
				wave VolumeDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
				wave Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
				wave Diameter=$("root:Packages:IR2L_NLSQF:Diameter_Pop"+num2str(i))
				NVAR DimensionIsDiameter = root:Packages:IR2L_NLSQF:SizeDist_DimensionIsDiameter
				if(DimensionIsDiameter) 				//all calculations above are done in radii, if we use Diameters, volume/number distributions needs to be half 
					IR2L_CalculateDistributions(i, Diameter, NumDist,VolumeDist)			
				else
					IR2L_CalculateDistributions(i, Radius, NumDist,VolumeDist)			
				endif		
				// Calculate intensity of the population...
				For(j=1;j<=10;j+=1)	//j is dataset
					IR2L_CalcIntPopXDataSetY(i,j)
				endfor
			elseif(stringMatch(Model,"Diffraction peak")) //diffraction peak
				//calculate diffraction peaks
				For(j=1;j<=10;j+=1)	//j is dataset
					IR2L_CalcDiffIntPopXDataSetY(i,j)
				endfor		
				wave/Z Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
				wave/Z NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
				wave/Z VolumeDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
				if(!skipCreateDistWvs || WaveExists(Radius) || WaveExists(NumDist) || WaveExists(VolumeDist))
					IR2L_CreateDistributionWaves(i)
				endif
				//next we calculate the distributions (Guass, Log-Normal or LSW)
				wave NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
				wave VolumeDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
				wave Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
				NumDist=0
				VolumeDist=0
				Radius=0
			elseif(stringMatch(Model,"Unified level"))	//unified level
				//calculate Unified model...				
				For(j=1;j<=10;j+=1)	//j is dataset
					IR2L_CalcUnifiedIntPopXDataSetY(i,j)
				endfor		
				wave/Z Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
				wave/Z NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
				wave/Z VolumeDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
				if(!skipCreateDistWvs || WaveExists(Radius) || WaveExists(NumDist) || WaveExists(VolumeDist))
					IR2L_CreateDistributionWaves(i)
					//print "created dist waves"
				endif
				//next we calculate the distributions (Guass, Log-Normal or LSW)
				wave NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
				wave VolumeDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
				wave Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
				NumDist=0
				VolumeDist=0
				Radius=0
			elseif(stringMatch(Model,"MassFractal"))	//unified level
				//calculate MassFractal				
				For(j=1;j<=10;j+=1)	//j is dataset
					IR2L_CalcMassFIntPopXDataSetY(i,j)
				endfor		
				wave/Z Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
				wave/Z NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
				wave/Z VolumeDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
				if(!skipCreateDistWvs || WaveExists(Radius) || WaveExists(NumDist) || WaveExists(VolumeDist))
					IR2L_CreateDistributionWaves(i)
					//print "created dist waves"
				endif
				//next we calculate the distributions (Guass, Log-Normal or LSW)
				wave NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
				wave VolumeDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
				wave Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
				NumDist=0
				VolumeDist=0
				Radius=0
			elseif(stringMatch(Model,"SurfaceFractal"))	//unified level
				//calculate SurfaceFractal				
				For(j=1;j<=10;j+=1)	//j is dataset
					IR2L_CalcSurfFIntPopXDataSetY(i,j)
				endfor		
				wave/Z Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
				wave/Z NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
				wave/Z VolumeDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
				if(!skipCreateDistWvs || WaveExists(Radius) || WaveExists(NumDist) || WaveExists(VolumeDist))
					IR2L_CreateDistributionWaves(i)
					//print "created dist waves"
				endif
				//next we calculate the distributions (Guass, Log-Normal or LSW)
				wave NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
				wave VolumeDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
				wave Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
				NumDist=0
				VolumeDist=0
				Radius=0
			endif
		endif
	endfor
	if(!fitting)
		//	//lets update the mode median and mean
		IR2L_UpdateModeMedianMean()		
		//	//now lets calculate the whole distribution together
		IR2L_CalcSumOfDistribution()
	endif
		//summ the model intensities
	IR2L_SummModel()		
		//fix smearing issues, fi needed...
	IR2L_FinishSmearingOfData()
	if(!fitting)
		//create residuals
		IR2L_CreateResidulas()
		//append to graph...
		IR2L_AppendModelToGraph()
		//NOw fix legend...
		IR2L_FormatLegend()
		// create the other graphs
		IR2L_CreateOtherGraphs()
	endif	
//	SetAxis /W=LSQF_MainGraph /A

end
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
Function IR2L_CalcMassFIntPopXDataSetY(pop,dataSet)
	variable pop,dataSet
	
//Calculate Intensity for pop X into data set Y

	string oldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF

	NVAR UseTheData=$("root:Packages:IR2L_NLSQF:UseTheData_set"+num2str(DataSet))
	NVAR UseThePop=$("root:Packages:IR2L_NLSQF:UseThePop_pop"+num2str(pop))
	NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
	variable LocalContrast
	variable UseDatasw=1
	if(!UseTheData || (!MultipleInputData && DataSet>1))
		UseDatasw=0
	endif
	if(UseThePop && UseDatasw)
//	//and now we need to calculate the model Intensity
//		NVAR QMin=$("root:Packages:IR2L_NLSQF:Qmin_set"+num2str(DataSet))
//		NVAR QMax=$("root:Packages:IR2L_NLSQF:Qmax_set"+num2str(DataSet))
//		Wave/Z Qwave=$("root:Packages:IR2L_NLSQF:Q_set"+num2str(DataSet))
//		if (!WaveExists (Qwave))
//			Abort "Select original data first"
//		endif
//		variable StartPoint, EndPoint
//		StartPoint = BinarySearch(Qwave, QMin)
//		EndPoint = BinarySearch(Qwave, QMax)
//		if(StartPoint<0)
//			StartPoint=0
//		endif
//		if(EndPoint<0)
//			EndPoint = numpnts(Qwave)-1
//		endif
//		Duplicate/O/R=[StartPoint,EndPoint] Qwave, $("Qmodel_set"+num2str(DataSet))
//		Wave ModelQ = $("Qmodel_set"+num2str(DataSet))
		Wave/Z ModelQ = $("Qmodel_set"+num2str(DataSet))
		if (!WaveExists (ModelQ))
			Abort "Select original data first"
		endif
		Duplicate/O ModelQ, $("IntensityModel_set"+num2str(DataSet)+"_pop"+num2str(pop))
		Wave ModelInt=$("IntensityModel_set"+num2str(DataSet)+"_pop"+num2str(pop))
		ModelInt=0

		//find the form factor parameters and name:
		NVAR Contrast=$("root:Packages:IR2L_NLSQF:Contrast_pop"+num2str(pop))
		NVAR SameContrastForDataSets=root:Packages:IR2L_NLSQF:SameContrastForDataSets
		NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
		NVAR Contrast_set=$("root:Packages:IR2L_NLSQF:Contrast_set"+num2str(DataSet)+"_pop"+num2str(pop))
		if(!SameContrastForDataSets || !MultipleInputData)		//weird stuff - if 1 it means that there are different contrasts for each data set... 
			LocalContrast=Contrast
		else
			LocalContrast=Contrast_set
		endif

		NVAR Phi=$("root:Packages:IR2L_NLSQF:MassFrPhi_pop"+num2str(pop))
		NVAR Radius=$("root:Packages:IR2L_NLSQF:MassFrRadius_pop"+num2str(pop))
		NVAR Dv=$("root:Packages:IR2L_NLSQF:MassFrDv_pop"+num2str(pop))
		NVAR Ksi=$("root:Packages:IR2L_NLSQF:MassFrKsi_pop"+num2str(pop))
		NVAR BetaVar=$("root:Packages:IR2L_NLSQF:MassFrBeta_pop"+num2str(pop))
		NVAR Eta=$("root:Packages:IR2L_NLSQF:MassFrEta_pop"+num2str(pop))
		
		variable CHiS=IR1V_CaculateChiS(BetaVar)
		variable RC=Radius*sqrt(2)/ChiS * sqrt(1+((2+BetaVar^2)/3)*ChiS^2)
		//and now calculations
		//	tempFractFitIntensity = Phi * Contrast* 1e20								//this is phi * deltaRhoSquared
		//	tempFractFitIntensity *= IR1V_SpheroidVolume(Radius,Beta)* 1e-24		//volume of particle
		variable Bracket
		Bracket = ( Eta * RC^3 / (BetaVar * Radius^3)) * ((Ksi/RC)^Dv )
		if(BetaVar!=1)
			ModelInt = Phi * LocalContrast* 1e-4 * IR1V_SpheroidVolume(Radius,BetaVar) * (Bracket * sin((Dv-1)*atan(ModelQ*Ksi)) / ((Dv-1)*ModelQ*Ksi*(1+(ModelQ*Ksi)^2)^((Dv-1)/2)) + (1-Eta)^2 )* IR2L_CalculateFSquared(pop,ModelQ)
		else
			ModelInt = Phi * LocalContrast* 1e-4 * IR1V_SpheroidVolume(Radius,BetaVar) * (Bracket * sin((Dv-1)*atan(ModelQ*Ksi)) / ((Dv-1)*ModelQ*Ksi*(1+(ModelQ*Ksi)^2)^((Dv-1)/2)) + (1-Eta)^2 )* IR2L_CalculateFSquared(pop,ModelQ)
		endif
		//	tempFractFitIntensity*=1e-48									//this is conversion for Volume of particles from A to cm	
	endif
end

///******************************************************************************************
///******************************************************************************************
///******************************************************************************************
///******************************************************************************************
///******************************************************************************************
///******************************************************************************************

Function IR2L_CalculateFSquared(which,Qval)
	variable which,Qval

	NVAR Phi=$("root:Packages:IR2L_NLSQF:MassFrPhi_pop"+num2str(which))
	NVAR Radius=$("root:Packages:IR2L_NLSQF:MassFrRadius_pop"+num2str(which))
	NVAR Dv=$("root:Packages:IR2L_NLSQF:MassFrDv_pop"+num2str(which))
	NVAR Ksi=$("root:Packages:IR2L_NLSQF:MassFrKsi_pop"+num2str(which))
	NVAR BetaVar=$("root:Packages:IR2L_NLSQF:MassFrBeta_pop"+num2str(which))
	NVAR Eta=$("root:Packages:IR2L_NLSQF:MassFrEta_pop"+num2str(which))
	NVAR IntgNumPnts=$("root:Packages:IR2L_NLSQF:MassFrIntgNumPnts_pop"+num2str(which))
	
	 variable result 
	 variable TempBessArg
	//now we need the integral
	Make/Free/D/N=(IntgNumPnts) FractF2IntgWave
	SetScale/I x 0,1,"", FractF2IntgWave
	FractF2IntgWave = Besselj(3/2,Qval*Radius*sqrt(1+(BetaVar^2 - 1)*x^2))/(Qval*Radius*sqrt(1+(BetaVar^2 - 1)*x^2))^(3/2)
	//fix end points, if they are wrong:
	if (numtype(FractF2IntgWave[0])!=0)
		FractF2IntgWave[0]=FractF2IntgWave[1]
	endif
	if (numtype(FractF2IntgWave[IntgNumPnts-1])!=0)
		FractF2IntgWave[IntgNumPnts-1]=FractF2IntgWave[IntgNumPnts-2]
	endif
	
	result =  9*pi/2 * (area(FractF2IntgWave, 0, 1 ))^2
	return result 
end

///******************************************************************************************
///******************************************************************************************
///******************************************************************************************
///******************************************************************************************
///******************************************************************************************
///******************************************************************************************

Function IR2L_CalcSurfFIntPopXDataSetY(pop,dataSet)
	variable pop,dataSet
//Calculate Intensity for pop X into data set Y

	
//Calculate Intensity for pop X into data set Y

	string oldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF

	NVAR UseTheData=$("root:Packages:IR2L_NLSQF:UseTheData_set"+num2str(DataSet))
	NVAR UseThePop=$("root:Packages:IR2L_NLSQF:UseThePop_pop"+num2str(pop))
	NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
	variable LocalContrast
	variable UseDatasw=1
	if(!UseTheData || (!MultipleInputData && DataSet>1))
		UseDatasw=0
	endif
	if(UseThePop && UseDatasw)
//	//and now we need to calculate the model Intensity
		//find the form factor parameters and name:
		NVAR Contrast=$("root:Packages:IR2L_NLSQF:Contrast_pop"+num2str(pop))
		NVAR SameContrastForDataSets=root:Packages:IR2L_NLSQF:SameContrastForDataSets
		NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
		NVAR Contrast_set=$("root:Packages:IR2L_NLSQF:Contrast_set"+num2str(DataSet)+"_pop"+num2str(pop))
		if(!SameContrastForDataSets || !MultipleInputData)		//weird stuff - if 1 it means that there are different contrasts for each data set... 
			LocalContrast=Contrast
		else
			LocalContrast=Contrast_set
		endif

//		NVAR QMin=$("root:Packages:IR2L_NLSQF:Qmin_set"+num2str(DataSet))
//		NVAR QMax=$("root:Packages:IR2L_NLSQF:Qmax_set"+num2str(DataSet))
//		Wave/Z Qwave=$("root:Packages:IR2L_NLSQF:Q_set"+num2str(DataSet))
//		if (!WaveExists (Qwave))
//			Abort "Select original data first"
//		endif
//		variable StartPoint, EndPoint
//		StartPoint = BinarySearch(Qwave, QMin)
//		EndPoint = BinarySearch(Qwave, QMax)
//		if(StartPoint<0)
//			StartPoint=0
//		endif
//		if(EndPoint<0)
//			EndPoint = numpnts(Qwave)-1
//		endif
//		Duplicate/O/R=[StartPoint,EndPoint] Qwave, $("Qmodel_set"+num2str(DataSet))
//		Wave ModelQ = $("Qmodel_set"+num2str(DataSet))
		Wave/Z ModelQ = $("Qmodel_set"+num2str(DataSet))
		if (!WaveExists (ModelQ))
			Abort "Select original data first"
		endif
		Duplicate/O ModelQ, $("IntensityModel_set"+num2str(DataSet)+"_pop"+num2str(pop))
		Wave ModelInt=$("IntensityModel_set"+num2str(DataSet)+"_pop"+num2str(pop))
		ModelInt=0

		//find the form factor parameters and name:
		NVAR Contrast=$("root:Packages:IR2L_NLSQF:Contrast_pop"+num2str(pop))
		NVAR SameContrastForDataSets=root:Packages:IR2L_NLSQF:SameContrastForDataSets
		NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
		NVAR Contrast_set=$("root:Packages:IR2L_NLSQF:Contrast_set"+num2str(DataSet)+"_pop"+num2str(pop))
		if(!SameContrastForDataSets || !MultipleInputData)		//weird stuff - if 1 it means that there are different contrasts for each data set... 
			LocalContrast=Contrast
		else
			LocalContrast=Contrast_set
		endif

		NVAR Surface=$("root:Packages:IR2L_NLSQF:SurfFrSurf_pop"+num2str(pop))
		NVAR DS=$("root:Packages:IR2L_NLSQF:SurfFrDS_pop"+num2str(pop))
		NVAR Ksi=$("root:Packages:IR2L_NLSQF:SurfFrKsi_pop"+num2str(pop))
		NVAR Qc=$("root:Packages:IR2L_NLSQF:SurfFrQc_pop"+num2str(pop))
		NVAR QcW=$("root:Packages:IR2L_NLSQF:SurfFrQcWidth_pop"+num2str(pop))


		//	ListOfVariables+="SurfFrSurf;SurfFrKsi;SurfFrDS;"
		//	ListOfVariables+="SurfFrQc;SurfFrQcWidth;"

		ModelInt = pi *LocalContrast* 1e20 * Ksi^4 *1e-32* Surface * exp(gammln(5-DS))	
		ModelInt *= sin((3-DS)* atan(ModelQ*Ksi))/((1+(ModelQ*Ksi)^2)^((5-DS)/2) * ModelQ*Ksi)
		if(Qc>0&& Qc<ModelQ[numpnts(ModelQ)-1])
			//h(Q) = C(xc - x)f(Q) + C(x - xc)g(Q).
			//The transition from one behavior to another is determined by C. Ê
			//For an infinitely sharp transition, C would be a Heaviside step function. Ê
			//Our choice for C is a smoothed step function:
			//C(x) = 0.5 * (1 + erfc(x/W)).
			//C(x) = 0.5 * (1 + ERF( (Qc-Q) /SQRT(2*((Qw/2.3548)^2) ) )
			duplicate/Free ModelInt, StepFunction1, StepFunction2, TempFractInt2
			StepFunction1 = 0.5 * (1 + erf((Qc - ModelQ)/SQRT(2*((Qc*QcW/2.3548)^2) ) ))
			StepFunction2 = 0.5 * (1 + erf((ModelQ - Qc)/SQRT(2*((Qc*QcW/2.3548)^2) ) ))
			//So, the total model, which transitions from f(Q) to Porod law behavior AQ^-4 is:
			//h(Q) = C(xc - x)f(Q) + C(x -xc)AQ^-4.
			//The value for A is not a free parameter. It is fixed by a continuity condition:
			//f(Qc) = g(Qc), or A = Qc^4 * f(Qc).
			//Intensity = ASF *Ê0.5 * (1 + ERF( (Qc-Q) /SQRT(2*((Qw/2.3548)^2) ) )Ê Ê +
			//+ ( ÊPf * Q^-4 *Ê0.5 * (1 + ERF( (Q-Qc) /SQRT(2*((Qw/2.3548)^2) ) )Ê
			variable PorodSurface=Qc^4 * ModelInt[BinarySearchInterp(ModelQ, Qc )]
			TempFractInt2 = ModelInt * StepFunction1 + PorodSurface * ModelQ^-4 * StepFunction2
			ModelInt = TempFractInt2
		endif
	endif
end


//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************

Function IR2L_CalcDiffIntPopXDataSetY(pop,dataSet)
	variable pop,dataSet

//Calculate Intensity for pop X into data set Y

	string oldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF

	NVAR UseTheData=$("root:Packages:IR2L_NLSQF:UseTheData_set"+num2str(DataSet))
	NVAR UseThePop=$("root:Packages:IR2L_NLSQF:UseThePop_pop"+num2str(pop))
	NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
	variable LocalContrast
	variable UseDatasw=1
	if(!UseTheData || (!MultipleInputData && DataSet>1))
		UseDatasw=0
	endif
	if(UseThePop && UseDatasw)
//	//and now we need to calculate the model Intensity
//		NVAR QMin=$("root:Packages:IR2L_NLSQF:Qmin_set"+num2str(DataSet))
//		NVAR QMax=$("root:Packages:IR2L_NLSQF:Qmax_set"+num2str(DataSet))
//		Wave/Z Qwave=$("root:Packages:IR2L_NLSQF:Q_set"+num2str(DataSet))
//		if (!WaveExists (Qwave))
//			Abort "Select original data first"
//		endif
//		variable StartPoint, EndPoint
//		StartPoint = BinarySearch(Qwave, QMin)
//		EndPoint = BinarySearch(Qwave, QMax)
//		if(StartPoint<0)
//			StartPoint=0
//		endif
//		if(EndPoint<0)
//			EndPoint = numpnts(Qwave)-1
//		endif
//		Duplicate/O/R=[StartPoint,EndPoint] Qwave, $("Qmodel_set"+num2str(DataSet))
		Wave/Z ModelQ = $("Qmodel_set"+num2str(DataSet))
		if (!WaveExists (ModelQ))
			Abort "Select original data first"
		endif
		Duplicate/O ModelQ, $("IntensityModel_set"+num2str(DataSet)+"_pop"+num2str(pop))
		Wave ModelInt=$("IntensityModel_set"+num2str(DataSet)+"_pop"+num2str(pop))
		ModelInt=0
		Duplicate/FREE ModelInt, tempInt

		//find the form factor parameters and name:
		SVAR DiffPeakProfile=$("root:Packages:IR2L_NLSQF:DiffPeakProfile_pop"+num2str(pop))	
		NVAR Par1=$("root:Packages:IR2L_NLSQF:DiffPeakPar1_pop"+num2str(pop))		
		NVAR Par2=$("root:Packages:IR2L_NLSQF:DiffPeakPar2_pop"+num2str(pop))		
		NVAR Par3=$("root:Packages:IR2L_NLSQF:DiffPeakPar3_pop"+num2str(pop))		
		NVAR Par4=$("root:Packages:IR2L_NLSQF:DiffPeakPar4_pop"+num2str(pop))		
		NVAR Par5=$("root:Packages:IR2L_NLSQF:DiffPeakPar5_pop"+num2str(pop))		
		NVAR Contrast=$("root:Packages:IR2L_NLSQF:Contrast_pop"+num2str(pop))
		NVAR SameContrastForDataSets=root:Packages:IR2L_NLSQF:SameContrastForDataSets
		NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
		NVAR Contrast_set=$("root:Packages:IR2L_NLSQF:Contrast_set"+num2str(DataSet)+"_pop"+num2str(pop))
		if(!SameContrastForDataSets || !MultipleInputData)		//weird stuff - if 1 it means that there are different contrasts for each data set... 
			LocalContrast=Contrast
		else
			LocalContrast=Contrast_set
		endif

		if(stringmatch(DiffPeakProfile, "Gauss" ))
//			tempInt =Par1*exp(-((qwv-Par2)^2/Par3))
			tempInt = IR2D_Gauss(ModelQ,Par1,Par2,Par3) 
			//Par1 * IR1_GaussProbability(qwv,Par2,Par3, 0)
		endif
		if(stringmatch(DiffPeakProfile, "Lorenz" ))
			tempInt = IR2D_Lorenz(ModelQ,Par1,Par2,Par3)
			//tempInt =(1/pi) *  Par1 * Par3/((qwv-Par2)^2+Par3^2) 	//from formula 10 at
			//http://mathworld.wolfram.com/CauchyDistribution.html
		endif
		if(stringmatch(DiffPeakProfile, "LorenzSquared" ))
			tempInt = IR2D_Lorenz2(ModelQ,Par1,Par2,Par3)
			//tempInt =(1/pi) *  Par1 * Par3/((qwv-Par2)^2+Par3^2) 	//from formula 10 at
			//http://mathworld.wolfram.com/CauchyDistribution.html
		endif

		if(stringmatch(DiffPeakProfile, "Pseudo-Voigt" ))
			tempInt = Par4*(IR2D_Lorenz(ModelQ,Par1,Par2,Par3)) + (1-Par4) *IR2D_Gauss(ModelQ,Par1,Par2,Par3)
			//tempInt =(1/pi) *  Par1 * Par3/((qwv-Par2)^2+Par3^2) 	//from formula 10 at
			//http://mathworld.wolfram.com/CauchyDistribution.html
		endif
		if(stringmatch(DiffPeakProfile, "Gumbel" ))
			tempInt = IR2D_Gumbel(ModelQ,Par1,Par2,Par3,Par4)
			//NIST handbook on statistics
			//http://mathworld.wolfram.com/CauchyDistribution.html
		endif
		if(stringmatch(DiffPeakProfile, "Pearson_VII" ))
			tempInt = IR2D_PearsonVII(ModelQ,Par1,Par2,Par3,Par4)
			//NIST handbook on statistics
			//http://mathworld.wolfram.com/CauchyDistribution.html
		endif
		if(stringmatch(DiffPeakProfile, "Modif_Gauss" ))
			tempInt = IR2D_ModifGauss(ModelQ,Par1,Par2,Par3,Par4)
			//NIST handbook on statistics
			//http://mathworld.wolfram.com/CauchyDistribution.html
		endif
		if(stringmatch(DiffPeakProfile, "LogNormal" ))
			tempInt = IR2D_LogNormal(ModelQ,Par1,Par2,Par3)
			//NIST handbook on statistics
			//http://mathworld.wolfram.com/CauchyDistribution.html
		endif
		if(stringmatch(DiffPeakProfile, "Percus-Yevick-Sq" ))
			tempInt = IR2D_PercusYevickSqNIST(ModelQ,Par1,Par2,Par3)
			//IR2D_PercusYevick(Q,Par1,Diameter,Fraction)
		endif
		if(stringmatch(DiffPeakProfile, "Percus-Yevick-SqFq" ))
			tempInt = IR2D_PercusYevickSqFqNIST(ModelQ,Par1,Par2,Par3)
			//IR2D_PercusYevick(Q,Par1,Diameter,Fraction)
		endif
		if(stringmatch(DiffPeakProfile, "SkewedNormal" ))
			tempInt = IR2D_SkewedNormal(ModelQ,Par1,Par2,Par3,Par4)
			//IR2D_PercusYevick(Q,Par1,Diameter,Fraction)
		endif

			NVAR PeakQPosition=$("DiffPeakQPos_pop"+num2str(pop))
			NVAR DiffPeakDPos=$("DiffPeakDPos_pop"+num2str(pop))
			NVAR PeakFWHM=$("DiffPeakQFWHM_pop"+num2str(pop))
			NVAR PeakIntgInt=$("DiffPeakIntgInt_pop"+num2str(pop))

			PeakIntgInt = areaXY(ModelQ, tempInt )
			SetScale/P x, 0, 1 , tempInt
			wavestats/Q tempInt
			PeakQPosition = ModelQ[V_maxloc]
			DiffPeakDPos = 2*pi/PeakQPosition
			FindLevels/Q  tempInt, V_max/2 
			if(V_flag==0)
				Wave W_FindLevels
				PeakFWHM = abs(ModelQ[W_FindLevels[1]] - ModelQ[W_FindLevels[0]])
			else
				PeakFWHM=nan
			endif

		ModelInt=LocalContrast*tempInt
	endif

	KillWaves/Z tempInt
	setDataFolder OldDf
end


//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
Function IR2L_CalcUnifiedIntPopXDataSetY(pop,dataSet)
	variable pop,dataSet

//Calculate Intensity for pop X into data set Y

	string oldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF

	NVAR UseTheData=$("root:Packages:IR2L_NLSQF:UseTheData_set"+num2str(DataSet))
	NVAR UseThePop=$("root:Packages:IR2L_NLSQF:UseThePop_pop"+num2str(pop))
	NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
	variable LocalContrast
	variable UseDatasw=1
	if(!UseTheData || (!MultipleInputData && DataSet>1))
		UseDatasw=0
	endif
	if(UseThePop && UseDatasw)
//	//and now we need to calculate the model Intensity
//		NVAR QMin=$("root:Packages:IR2L_NLSQF:Qmin_set"+num2str(DataSet))
//		NVAR QMax=$("root:Packages:IR2L_NLSQF:Qmax_set"+num2str(DataSet))
//		Wave/Z Qwave=$("root:Packages:IR2L_NLSQF:Q_set"+num2str(DataSet))
//		if (!WaveExists (Qwave))
//			Abort "Select original data first"
//		endif
//		variable StartPoint, EndPoint
//		StartPoint = BinarySearch(Qwave, QMin)
//		EndPoint = BinarySearch(Qwave, QMax)
//		if(StartPoint<0)
//			StartPoint=0
//		endif
//		if(EndPoint<0)
//			EndPoint = numpnts(Qwave)-1
//		endif
//		Duplicate/O/R=[StartPoint,EndPoint] Qwave, $("Qmodel_set"+num2str(DataSet))
//		Wave ModelQ = $("Qmodel_set"+num2str(DataSet))
		Wave/Z ModelQ = $("Qmodel_set"+num2str(DataSet))
		if (!WaveExists (ModelQ))
			Abort "Select original data first"
		endif

		Duplicate/O ModelQ, $("IntensityModel_set"+num2str(DataSet)+"_pop"+num2str(pop))
		Wave ModelInt=$("IntensityModel_set"+num2str(DataSet)+"_pop"+num2str(pop))
		ModelInt=0

		//find the form factor parameters and name:
		SVAR FormFactor=$("root:Packages:IR2L_NLSQF:FormFactor_pop"+num2str(pop))	
		SVAR FFUserFFformula=$("root:Packages:IR2L_NLSQF:FFUserFFformula_pop"+num2str(pop))	
		SVAR FFUserVolumeFormula=$("root:Packages:IR2L_NLSQF:FFUserVolumeFormula_pop"+num2str(pop))	
		NVAR FF_Param1=$("root:Packages:IR2L_NLSQF:FormFactor_Param1_pop"+num2str(pop))		
		NVAR FF_Param2=$("root:Packages:IR2L_NLSQF:FormFactor_Param2_pop"+num2str(pop))		
		NVAR FF_Param3=$("root:Packages:IR2L_NLSQF:FormFactor_Param3_pop"+num2str(pop))		
		NVAR FF_Param4=$("root:Packages:IR2L_NLSQF:FormFactor_Param4_pop"+num2str(pop))		
		NVAR FF_Param5=$("root:Packages:IR2L_NLSQF:FormFactor_Param5_pop"+num2str(pop))		
		NVAR FF_Param6=$("root:Packages:IR2L_NLSQF:FormFactor_Param6_pop"+num2str(pop))		
		NVAR Contrast=$("root:Packages:IR2L_NLSQF:Contrast_pop"+num2str(pop))
		NVAR SameContrastForDataSets=root:Packages:IR2L_NLSQF:SameContrastForDataSets
		NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
		NVAR Contrast_set=$("root:Packages:IR2L_NLSQF:Contrast_set"+num2str(DataSet)+"_pop"+num2str(pop))
		if(!SameContrastForDataSets || !MultipleInputData)		//weird stuff - if 1 it means that there are different contrasts for each data set... 
			LocalContrast=Contrast
		else
			LocalContrast=Contrast_set
		endif

		NVAR G=$("root:Packages:IR2L_NLSQF:UF_G_pop"+num2str(pop))
		NVAR Rg=$("root:Packages:IR2L_NLSQF:UF_Rg_pop"+num2str(pop))
		NVAR B=$("root:Packages:IR2L_NLSQF:UF_B_pop"+num2str(pop))
		NVAR P=$("root:Packages:IR2L_NLSQF:UF_P_pop"+num2str(pop))
		NVAR RGCO=$("root:Packages:IR2L_NLSQF:UF_RGCO_pop"+num2str(pop))
		NVAR Kval=$("root:Packages:IR2L_NLSQF:UF_K_pop"+num2str(pop))
		NVAR/Z LinkB=$("root:Packages:IR2L_NLSQF:UF_LinkB_pop"+num2str(pop))
		variable LLinkB=0
		if(NVAR_Exists(LinkB))
			LLinkB=LinkB
		endif
		//now the distribution waves...
		//calculate Unified fit....
		if(LLinkB)
			B = G * exp(-1*P/2)*(3*P/2)^(P/2)*(1/Rg^P) 
		endif
		
		Duplicate /O ModelQ, QstarVector
		QstarVector=ModelQ/(erf(Kval*ModelQ*Rg/sqrt(6)))^3
		ModelInt=LocalContrast*G*exp(-ModelQ^2*Rg^2/3)+(LocalContrast*B/QstarVector^P) * exp(-RGCO^2 * ModelQ^2/3)
	
		//Interference, if needed
			NVAR Phi = $("root:Packages:IR2L_NLSQF:StructureParam2_pop"+num2str(pop))
			NVAR Eta = $("root:Packages:IR2L_NLSQF:StructureParam1_pop"+num2str(pop))
			NVAR WellDepthPert = $("root:Packages:IR2L_NLSQF:StructureParam3_pop"+num2str(pop))
			NVAR WellWidthStick = $("root:Packages:IR2L_NLSQF:StructureParam4_pop"+num2str(pop))
			NVAR Par5 = $("root:Packages:IR2L_NLSQF:StructureParam5_pop"+num2str(pop))
			NVAR Par6 = $("root:Packages:IR2L_NLSQF:StructureParam6_pop"+num2str(pop))
			SVAR StrFac=$("root:Packages:IR2L_NLSQF:StructureFactor_pop"+num2str(pop))
			SVAR SFUserSFformula = $("root:Packages:IR2L_NLSQF:SFUserSQFormula_pop"+num2str(pop))
			ModelInt *=  IR2S_CalcStructureFactor(StrFac,ModelQ,Eta,Phi,WellDepthPert,WellWidthStick,Par5,Par6,UserStrFacFormula=SFUserSFformula)		//this returns 1 in case of dilute system
		endif
//	endif


//	endif
//
	setDataFolder OldDf
end
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************


Function IR2L_CalcSumOfDistribution() //Sums the existing populations and creates distribution to plot...

	string OldDf
	OldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF
	
	variable i, tempLength=0
	Make/O/N=0/D DistRadia, DistDiameters
	
	For(i=1;i<11;i+=1)
		NVAR UseThePop=$("root:Packages:IR2L_NLSQF:UseThePop_pop"+num2str(i))
		SVAR FormFactor=$("root:Packages:IR2L_NLSQF:FormFactor_pop"+num2str(i))
		SVAR Model=$("root:Packages:IR2L_NLSQF:Model_pop"+num2str(i))
		Wave/Z NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
		Wave/Z RDist=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
		Wave/Z VolDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
		if(UseThePop&&!(stringMatch(Model,"Unified level")||stringMatch(Model,"Diffraction peak")))
			tempLength=numpnts(DistRadia)
			redimension /N=(tempLength+numpnts(RDist)) DistRadia
		//	DistRadia[tempLength,numpnts(RDist)-1]=RDist[p-tempLength]
			DistRadia[tempLength,inf]=RDist[p-tempLength]
		endif
	endfor

	Sort DistRadia, DistRadia
	//check if some of the point are the same, that causes trobles later. remove the points
	variable imax=numpnts(DistRadia)
	For(i=imax;i>0;i-=1)
		if(DistRadia(i)==DistRadia(i-1))
			DeletePoints i,1, DistRadia
		endif
	endfor

	Duplicate/O DistRadia, DistDiameters
	DistDiameters = 2 * DistRadia

	Duplicate/O DistRadia, TempVolDist, TempNumDist, TotalVolumeDist, TotalNumberDist
	Redimension/D TempVolDist, TempNumDist, TotalVolumeDist, TotalNumberDist	
	TotalVolumeDist=0
	TotalNumberDist=0
	
	For(i=1;i<11;i+=1)	
		NVAR UseThePop=$("root:Packages:IR2L_NLSQF:UseThePop_pop"+num2str(i))
		SVAR FormFactor=$("root:Packages:IR2L_NLSQF:FormFactor_pop"+num2str(i))
		SVAR Model=$("root:Packages:IR2L_NLSQF:Model_pop"+num2str(i))
		if(UseThePop&&!(stringMatch(Model,"Unified level")||stringMatch(Model,"Diffraction peak")))
			NVAR DimensionIsDiameter = root:Packages:IR2L_NLSQF:SizeDist_DimensionIsDiameter
			if(DimensionIsDiameter) 				//all calculations above are done in radii, if we use Diameters, volume/number distributions needs to be half 
				IR2L_CalculateDistributions(i, DistDiameters, TempNumDist,TempVolDist)		
			else
				IR2L_CalculateDistributions(i, DistRadia, TempNumDist,TempVolDist)		
			endif		
			TotalVolumeDist+=TempVolDist
			TotalNumberDist+=TempNumDist
		endif
	endfor
	KillWaves/Z TempVolDist, TempNumDist	
	setDataFolder OldDf	
end


//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************

Function IR2L_GraphSizeDistributions() : Graph

	String fldrSav0= GetDataFolder(1)
	SetDataFolder root:Packages:IR2L_NLSQF:
	NVAR DisplaySizeDistPlot=root:Packages:IR2L_NLSQF:DisplaySizeDistPlot
	variable SizeDistExisted
	SizeDistExisted = 0

	DoWindow GraphSizeDistributions
	SizeDistExisted=V_Flag
	if(DisplaySizeDistPlot)
		if(V_Flag)
			DoWindow/F GraphSizeDistributions
		else
			Display/K=1 /W=(312.75,392.75,857.25,607.25)  as "Size distributions"
			DoWindow/C GraphSizeDistributions
			//Add command bar
			ControlBar /T/W=GraphSizeDistributions 40
			Checkbox SizeDistLogX, pos={5,3}, size={20,25}, variable= root:Packages:IR2L_NLSQF:SizeDistLogX, help={"X axis (Radius) -log scale?"}, title="Log X axis? ", proc=IR2L_SizeDistGraphChkbxProc, win=GraphSizeDistributions
			Checkbox SizeDistDisplayVolDist, pos={100,3}, size={50,25}, variable= root:Packages:IR2L_NLSQF:SizeDistDisplayVolDist, help={"Display Volume Distribution?"}, title="Display Vol Dist? ", proc=IR2L_SizeDistGraphChkbxProc, win=GraphSizeDistributions
			Checkbox SizeDistDisplayNumDist, pos={100,23}, size={50,25}, variable= root:Packages:IR2L_NLSQF:SizeDistDisplayNumDist, help={"Display Number distribution ?"}, title="Display Num Dist? ", proc=IR2L_SizeDistGraphChkbxProc, win=GraphSizeDistributions
			Checkbox SizeDistLogVolDist, pos={220,3}, size={50,25}, variable= root:Packages:IR2L_NLSQF:SizeDistLogVolDist, help={"Volume distribution axis log scale?"}, title="Log Vol Dist? ", proc=IR2L_SizeDistGraphChkbxProc, win=GraphSizeDistributions
			Checkbox SizeDistLogNumDist, pos={220,23}, size={50,25}, variable= root:Packages:IR2L_NLSQF:SizeDistLogNumDist, help={"Number distribution axis log scale?"}, title="Log Num Dist? ", proc=IR2L_SizeDistGraphChkbxProc, win=GraphSizeDistributions
			SetVariable MeanVal, limits={0,inf,0}, NoProc, noedit=1, win=GraphSizeDistributions
			SetVariable MeanVal, pos={320,3}, size={180,25}, variable= root:Packages:IR2L_NLSQF:Mean_pop1, help={"Mean of current population"}, title="Pop 1 Mean = "
			SetVariable ModeVal, limits={0,inf,0}, NoProc, noedit=1, win=GraphSizeDistributions
			SetVariable ModeVal, pos={320,23}, size={180,25}, variable= root:Packages:IR2L_NLSQF:Mode_pop1, help={"Mode of current population"}, title="Pop 1 Mode = "
	
			SetVariable MedianVal, limits={0,inf,0}, NoProc, noedit=1, win=GraphSizeDistributions
			SetVariable MedianVal, pos={520,3}, size={180,25}, variable= root:Packages:IR2L_NLSQF:Median_pop1, help={"Median of current population"}, title="Pop 1 Median = "
			SetVariable FWHMVal, limits={0,inf,0}, NoProc, noedit=1, win=GraphSizeDistributions
			SetVariable FWHMVal, pos={520,23}, size={180,25}, variable= root:Packages:IR2L_NLSQF:FWHM_pop1, help={"FWHM of current population"}, title="Pop 1 FWHM = "
		endif
	else
		if(V_Flag)
			KillWIndow GraphSizeDistributions
		endif
		return 0
	endif

	IR2L_GraphSizeDistUpdate()	
	
	IR2L_AppendWvsGraphSizeDist()
	
	IR2L_FormatGraphSizeDist()

	IR2M_ColorCurves()
	SetDataFolder fldrSav0	
	return SizeDistExisted
End

//*****************************************************************************************************************
//*****************************************************************************************************************

Function IR2L_GraphSizeDistUpdate()

	DoWindow GraphSizeDistributions
	if(V_Flag)
		ControlInfo/W=LSQF2_MainPanel DistTabs
		DoWindow/F GraphSizeDistributions
		variable curPopulation=V_Value+1
		SetVariable MeanVal, win=GraphSizeDistributions, variable=root:Packages:IR2L_NLSQF:$("Mean_pop"+num2str(curPopulation)), title="Pop "+num2str(curPopulation)+" Mean = "
		SetVariable ModeVal, win=GraphSizeDistributions,  variable= root:Packages:IR2L_NLSQF:$("Mode_pop"+num2str(curPopulation)), title="Pop "+num2str(curPopulation)+" Mode = "
		SetVariable MedianVal, win=GraphSizeDistributions,  variable= root:Packages:IR2L_NLSQF:$("Median_pop"+num2str(curPopulation)), title="Pop "+num2str(curPopulation)+" Median = "
		SetVariable FWHMVal, win=GraphSizeDistributions,  variable= root:Packages:IR2L_NLSQF:$("FWHM_pop"+num2str(curPopulation)), title="Pop "+num2str(curPopulation)+" FWHM = "
	else
		return 1
	endif


end 
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************


Function IR2L_SizeDistGraphChkbxProc(ctrlName,checked) : CheckBoxControl
	String ctrlName
	Variable checked

//	ListOfVariables+="SizeDistLogX;SizeDistDisplayNumDist;SizeDistDisplayVolDist;"
//	ListOfVariables+="SizeDistLogVolDist;SizeDistLogNumDist;"
	NVAR SizeDistDisplayNumDist = root:Packages:IR2L_NLSQF:SizeDistDisplayNumDist
	NVAR SizeDistDisplayVolDist = root:Packages:IR2L_NLSQF:SizeDistDisplayVolDist
	if(stringmatch(ctrlName,"SizeDistDisplayVolDist"))
		if(SizeDistDisplayVolDist==0)
			SizeDistDisplayNumDist=1
		endif
	endif
	if(stringmatch(ctrlName,"SizeDistDisplayNumDist"))
		if(SizeDistDisplayNumDist==0)
			SizeDistDisplayVolDist=1
		endif
	endif
	IR2L_AppendWvsGraphSizeDist()
	IR2L_FormatGraphSizeDist()
	IR2M_ColorCurves()
End
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************


Function IR2L_AppendWvsGraphSizeDist()

	String fldrSav0= GetDataFolder(1)
	SetDataFolder root:Packages:IR2L_NLSQF:
	NVAR SizeDistLogX = root:Packages:IR2L_NLSQF:SizeDistLogX
	NVAR SizeDistDisplayNumDist = root:Packages:IR2L_NLSQF:SizeDistDisplayNumDist
	NVAR SizeDistDisplayVolDist = root:Packages:IR2L_NLSQF:SizeDistDisplayVolDist
	NVAR SizeDistLogVolDist = root:Packages:IR2L_NLSQF:SizeDistLogVolDist
	NVAR SizeDistLogNumDist = root:Packages:IR2L_NLSQF:SizeDistLogNumDist
	SVAR SizeDist_DimensionType=root:Packages:IR2L_NLSQF:SizeDist_DimensionType
	
	variable i

	Wave/Z DistRadii=root:Packages:IR2L_NLSQF:DistRadia
	Wave/Z TotalNumberDist=root:Packages:IR2L_NLSQF:TotalNumberDist
	Wave/Z TotalVolumeDist=root:Packages:IR2L_NLSQF:TotalVolumeDist	
	if(!WaveExists(DistRadii))
		return 0		//data do not exist... 
	endif
	DoWIndow GraphSizeDistributions
	if(V_FLag)
		if(SizeDistDisplayNumDist)
			CheckDisplayed /W=GraphSizeDistributions TotalNumberDist
			if(!V_Flag)
				AppendToGraph /R/W=GraphSizeDistributions TotalNumberDist vs DistRadii
			endif
		else
			RemoveFromGraph/Z/W=GraphSizeDistributions TotalNumberDist
		endif
		if(SizeDistDisplayVolDist)
			CheckDisplayed /W=GraphSizeDistributions TotalVolumeDist
			if(!V_Flag)
				AppendToGraph /W=GraphSizeDistributions TotalVolumeDist vs DistRadii
			endif
		else
			RemoveFromGraph/Z/W=GraphSizeDistributions TotalVolumeDist
		endif
	endif
		
	For(i=1;i<11;i+=1)
		NVAR UseThePop=$("root:Packages:IR2L_NLSQF:UseThePop_pop"+num2str(i))
		Wave/Z NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(i))
		Wave/Z RDist=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(i))
		Wave/Z VolDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(i))
		DOWindow GraphSizeDistributions
		if(V_Flag)
			CheckDisplayed /W=GraphSizeDistributions $("NumberDist_Pop"+num2str(i))
		
			if(SizeDistDisplayNumDist && !V_Flag && UseThePop)
				AppendToGraph/R/W=GraphSizeDistributions NumDist vs RDist
			elseif(!SizeDistDisplayNumDist || !UseThePop)
				RemoveFromGraph/Z /W=GraphSizeDistributions $("NumberDist_Pop"+num2str(i))
			endif

			CheckDisplayed /W=GraphSizeDistributions $("VolumeDist_Pop"+num2str(i))
			if(SizeDistDisplayVolDist && !V_Flag && UseThePop)
				AppendToGraph/W=GraphSizeDistributions VolDist vs RDist
			elseif(!SizeDistDisplayVolDist || !UseThePop)
				RemoveFromGraph/Z /W=GraphSizeDistributions $("VolumeDist_Pop"+num2str(i))
			endif
		endif
	endfor

	DOWindow GraphSizeDistributions
	if(V_Flag)
		Label/Z /W=GraphSizeDistributions bottom SizeDist_DimensionType+" [A]"
		if(SizeDistDisplayNumDist)
			Label /Z/W=GraphSizeDistributions right "Number distribution [1/(A*cm\\S3\\M)]"
		endif
		if(!SizeDistDisplayNumDist)
			ModifyGraph /Z/W=GraphSizeDistributions mirror(left)=1
		endif
		if(SizeDistDisplayVolDist)
			Label/Z /W=GraphSizeDistributions left "Volume distribution f(R) [1/A]"
		endif	
		if(!SizeDistDisplayVolDist)
			ModifyGraph/Z /W=GraphSizeDistributions mirror(right)=1
	endif
	endif
	SetDataFolder fldrSav0	
End
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************


Function IR2L_FormatGraphSizeDist()

	String fldrSav0= GetDataFolder(1)
	SetDataFolder root:Packages:IR2L_NLSQF:

//	ListOfVariables+="SizeDistLogX;SizeDistDisplayNumDist;SizeDistDisplayVolDist;"
//	ListOfVariables+="SizeDistLogVolDist;SizeDistLogNumDist;"
	NVAR SizeDistLogX = root:Packages:IR2L_NLSQF:SizeDistLogX
	NVAR SizeDistDisplayNumDist = root:Packages:IR2L_NLSQF:SizeDistDisplayNumDist
	NVAR SizeDistDisplayVolDist = root:Packages:IR2L_NLSQF:SizeDistDisplayVolDist
	NVAR SizeDistLogVolDist = root:Packages:IR2L_NLSQF:SizeDistLogVolDist
	NVAR SizeDistLogNumDist = root:Packages:IR2L_NLSQF:SizeDistLogNumDist
	if(SizeDistLogX)
			ModifyGraph/Z /W=GraphSizeDistributions log(bottom)=1
	else
			ModifyGraph/Z /W=GraphSizeDistributions log(bottom)=0
	endif
	if(SizeDistLogVolDist && SizeDistDisplayVolDist)
		ModifyGraph/Z /W=GraphSizeDistributions log(left)=1
	elseif(!SizeDistLogVolDist && SizeDistDisplayVolDist)
		ModifyGraph/Z /W=GraphSizeDistributions log(left)=0
	endif
	if(SizeDistLogNumDist && SizeDistDisplayNumDist)
		ModifyGraph/Z /W=GraphSizeDistributions log(right)=1
	elseif(!SizeDistLogNumDist && SizeDistDisplayNumDist)
		ModifyGraph/Z /W=GraphSizeDistributions log(right)=0
	endif
	ModifyGraph/Z /W=GraphSizeDistributions mirror(bottom)=1
///	ModifyGraph /W=GraphSizeDistributions lblMargin(left)=3,lblMargin(right)=15

	Legend/C/N=text0/S=3/A=RT
	setAxis/A

	SetDataFolder fldrSav0	
End

//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************

Function IR2L_CalcIntPopXDataSetY(pop,dataSet)
	variable pop,dataSet

//Calculate Intensity for pop X into data set Y

	string oldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF

	NVAR UseTheData=$("root:Packages:IR2L_NLSQF:UseTheData_set"+num2str(DataSet))
	NVAR UseThePop=$("root:Packages:IR2L_NLSQF:UseThePop_pop"+num2str(pop))
	NVAR UseNumberDistributions=root:Packages:IR2L_NLSQF:UseNumberDistributions
	NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
	variable LocalContrast
	variable UseDatasw=1
	if(!UseTheData || (!MultipleInputData && DataSet>1))
		UseDatasw=0
	endif
	if(UseThePop && UseDatasw)
//	//and now we need to calculate the model Intensity
//	here we need to get the G matrix for each population and DataSet separately... 	
// 	then calculate 
//	IR1_CalculateModelIntensity()		<<< old example...
//		NVAR QMin=$("root:Packages:IR2L_NLSQF:Qmin_set"+num2str(DataSet))
//		NVAR QMax=$("root:Packages:IR2L_NLSQF:Qmax_set"+num2str(DataSet))
//		Wave/Z Qwave=$("root:Packages:IR2L_NLSQF:Q_set"+num2str(DataSet))
//		if (!WaveExists (Qwave))
//			Abort "Select original data first"
//		endif
//		variable StartPoint, EndPoint
//		StartPoint = BinarySearch(Qwave, QMin)
//		EndPoint = BinarySearch(Qwave, QMax)
//		if(StartPoint<0)
//			StartPoint=0
//		endif
//		if(EndPoint<0)
//			EndPoint = numpnts(Qwave)-1
//		endif
//		Duplicate/O/R=[StartPoint,EndPoint] Qwave, $("Qmodel_set"+num2str(DataSet))
		Wave/Z ModelQ = $("Qmodel_set"+num2str(DataSet))
		if (!WaveExists (ModelQ))
			Abort "Select original data first"
		endif
		Duplicate/O ModelQ, $("IntensityModel_set"+num2str(DataSet)+"_pop"+num2str(pop))
		Wave ModelInt=$("IntensityModel_set"+num2str(DataSet)+"_pop"+num2str(pop))
		ModelInt=0

		//find the form factor parameters and name:
		SVAR FormFactor=$("root:Packages:IR2L_NLSQF:FormFactor_pop"+num2str(pop))	
		SVAR FFUserFFformula=$("root:Packages:IR2L_NLSQF:FFUserFFformula_pop"+num2str(pop))	
		SVAR FFUserVolumeFormula=$("root:Packages:IR2L_NLSQF:FFUserVolumeFormula_pop"+num2str(pop))	
		NVAR FF_Param1=$("root:Packages:IR2L_NLSQF:FormFactor_Param1_pop"+num2str(pop))		
		NVAR FF_Param2=$("root:Packages:IR2L_NLSQF:FormFactor_Param2_pop"+num2str(pop))		
		NVAR FF_Param3=$("root:Packages:IR2L_NLSQF:FormFactor_Param3_pop"+num2str(pop))		
		NVAR FF_Param4=$("root:Packages:IR2L_NLSQF:FormFactor_Param4_pop"+num2str(pop))		
		NVAR FF_Param5=$("root:Packages:IR2L_NLSQF:FormFactor_Param5_pop"+num2str(pop))		
		NVAR FF_Param6=$("root:Packages:IR2L_NLSQF:FormFactor_Param6_pop"+num2str(pop))		
		NVAR Contrast=$("root:Packages:IR2L_NLSQF:Contrast_pop"+num2str(pop))
		NVAR SameContrastForDataSets=root:Packages:IR2L_NLSQF:SameContrastForDataSets
		NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
		NVAR Contrast_set=$("root:Packages:IR2L_NLSQF:Contrast_set"+num2str(DataSet)+"_pop"+num2str(pop))
		if(!SameContrastForDataSets || !MultipleInputData)		//weird stuff - if 1 it means that there are different contrasts for each data set... 
			LocalContrast=Contrast
		else
			LocalContrast=Contrast_set
		endif
		//now the distribution waves...
		Wave Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(pop))
		Wave NumDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(pop))
		Wave VolDist= $("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(pop))
		//now lets look for the existing Gmatrix_setX_popY
		Wave/Z Gmatrix=$("root:Packages:IR2L_NLSQF:Gmatrix_set"+num2str(DataSet)+"_pop"+num2str(pop))
		variable M=numpnts(ModelQ)
		variable N=numpnts(Radius)
		if(!WaveExists(Gmatrix))
			Make/D/O/N=(M,N) $("Gmatrix_set"+num2str(DataSet)+"_pop"+num2str(pop))
			Wave Gmatrix=$("root:Packages:IR2L_NLSQF:Gmatrix_set"+num2str(DataSet)+"_pop"+num2str(pop))
		endif	
		//calculate G matrix...
		
		if(UseNumberDistributions)
			IR1T_GenerateGMatrix(Gmatrix, ModelQ,Radius,2,FormFactor,FF_Param1,FF_Param2,FF_Param3,FF_Param4,FF_Param5,FFUserFFformula,FFUserVolumeFormula, ParticlePar6=FF_Param6)
		else
			IR1T_GenerateGMatrix(Gmatrix, ModelQ,Radius,1,FormFactor,FF_Param1,FF_Param2,FF_Param3,FF_Param4,FF_Param5,FFUserFFformula,FFUserVolumeFormula, ParticlePar6=FF_Param6)
		endif
		//Duplicate/O G_matrixFF, $("G_matrix_"+num2str(DistNum))				//G_matrixFF (root:Packages:Sizes:G_matrixFF)  contains form factor without contrast, except for Tube and Core shell...  
		//Wave G_matrix=$("G_matrix_"+num2str(DistNum))
		//here need to use copy of the G matrix, so we do not include contrast in it...
		if(cmpstr(FormFactor,"CoreShell")==0 || cmpstr(FormFactor,"CoreShellCylinder")==0 || cmpstr(FormFactor,"CoreShellShell")==0|| stringmatch(FormFactor,"Janus CoreShell Micelle*"))
			MatrixOP/O GmatrixTemp = Gmatrix * 1e20			//this shape contains contrast already in...
		else
			MatrixOP/O GmatrixTemp = Gmatrix * LocalContrast*1e20		//this multiplies by scattering contrast
		endif

		if(UseNumberDistributions)
			duplicate/O NumDist, TepNumbDist
			TepNumbDist=NumDist[p]* IR1_BinWidthInDiameters(Radius,p)
			MatrixOp/O ModelInt =GmatrixTemp x TepNumbDist 
		else
			duplicate/O VolDist, TepVolumeDist
			TepVolumeDist=VolDist[p]* IR1_BinWidthInDiameters(Radius,p)
			MatrixOp/O ModelInt =GmatrixTemp x TepVolumeDist 
			Killwaves/Z GmatrixTemp
		endif

		//special cases, we need to update some parameters here...
		if(stringmatch(FormFactor,"CoreShellPrecipitate"))
			wavestats/Q Radius
			FF_Param1 = IR1T_FixCoreShellPrecipitate(V_avg,0,FF_Param2,FF_Param3,FF_Param4,2)
		endif
		
		NVAR Phi = $("root:Packages:IR2L_NLSQF:StructureParam2_pop"+num2str(pop))
		NVAR Eta = $("root:Packages:IR2L_NLSQF:StructureParam1_pop"+num2str(pop))
		NVAR WellDepthPert = $("root:Packages:IR2L_NLSQF:StructureParam3_pop"+num2str(pop))
		NVAR WellWidthStick = $("root:Packages:IR2L_NLSQF:StructureParam4_pop"+num2str(pop))
		NVAR Par5 = $("root:Packages:IR2L_NLSQF:StructureParam5_pop"+num2str(pop))
		NVAR Par6 = $("root:Packages:IR2L_NLSQF:StructureParam6_pop"+num2str(pop))
		//OK, new method... 
		SVAR StrFac=$("root:Packages:IR2L_NLSQF:StructureFactor_pop"+num2str(pop))
		SVAR SFUserSFformula = $("root:Packages:IR2L_NLSQF:SFUserSQFormula_pop"+num2str(pop))
		ModelInt *=  IR2S_CalcStructureFactor(StrFac,ModelQ,Eta,Phi,WellDepthPert,WellWidthStick,Par5,Par6, UserStrFacFormula=SFUserSFformula)		//this returns 1 in case of dilute system
	endif

	setDataFolder OldDf
end
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
Function IR2L_SummModel()

	string OldDf
	OldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF
	variable i, j
	//i is 1 - 6 populations
	//j is 1 - 10 data sets
	NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
	variable UseDatasw=1
	
	For(j=1;j<11;j+=1)
		NVAR UseTheData=$("root:Packages:IR2L_NLSQF:UseTheData_set"+num2str(j))
		NVAR Background=$("root:Packages:IR2L_NLSQF:Background_set"+num2str(j))
		UseDatasw=1
		if(!UseTheData || (!MultipleInputData && j>1))
			UseDatasw=0
		endif
		if(UseDatasw)
			Wave/Z ModelQ = $("Qmodel_set"+num2str(j))
			if(!WaveExists(ModelQ))
				return 1
			endif
			Duplicate/O ModelQ, $("IntensityModel_set"+num2str(j))
			Wave ModelIntSumm=$("IntensityModel_set"+num2str(j))
			Wave Intensity=$("Intensity_set"+num2str(j))
			Wave Error=$("Error_set"+num2str(j))
			ModelIntSumm=0
			For(i=1;i<=10;i+=1)
				NVAR UseThePop=$("root:Packages:IR2L_NLSQF:UseThePop_pop"+num2str(i))
				if(UseThePop)
					Wave ModelInt=$("IntensityModel_set"+num2str(j)+"_pop"+num2str(i))
					ModelIntSumm+=ModelInt
				endif
			endfor
			ModelIntSumm+=Background			//add background... Only once for each data set...
		endif
		
	endfor


	setDataFolder OldDf	
end
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
Function IR2L_SlitSmearLSQFData(IntWave,Qwave,SlitLength)
	wave IntWave,Qwave
	variable SlitLength
	
	string OldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF
	Duplicate/Free IntWave, SmearedIntWave
	IR1B_SmearData(IntWave,Qwave, slitLength, SmearedIntWave)
	IntWave=SmearedIntWave
end
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
Function IR2L_AppendModelToGraph()

	string OldDf
	OldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF
	variable i, j
	//i is 1 - 6 populations
	//j is 1 - 10 data sets
	NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
	variable UseDatasw=1
	
	For(j=1;j<11;j+=1)
		NVAR UseTheData=$("root:Packages:IR2L_NLSQF:UseTheData_set"+num2str(j))
		UseDatasw=1
		if(!UseTheData || (!MultipleInputData && j>1))
			UseDatasw=0
		endif
		Wave/Z ModelQ = $("Qmodel_set"+num2str(j))
		Wave/Z ModelIntSumm=$("IntensityModel_set"+num2str(j))
		DoWIndow LSQF_MainGraph
		if(!V_Flag)
			return  0 //no widnow open, do not bomb on user...
		endif
		CheckDisplayed/W=LSQF_MainGraph $("IntensityModel_set"+num2str(j))
		if(UseDatasw && V_Flag)
			//use the data and displayed, nothing to do
		elseif(UseDatasw && !V_Flag)
			//use the data and NOT displayed, append
			if(WaveExists(ModelIntSumm) && WaveExists(ModelQ))
				AppendToGraph/W=LSQF_MainGraph ModelIntSumm vs ModelQ
			endif
		elseif(!UseDataSw)
			//do nto use these data
			RemoveFromGraph/Z/W=LSQF_MainGraph $("IntensityModel_set"+num2str(j))
		endif
	endfor

	IR2L_FormatInputGraph()
	setDataFolder OldDf	
end

//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************

Function IR2L_CreateOtherGraphs()
		//	//create graphs, if needed...
		variable SizeDistExisted, ResidualsExisted, IQ4Existed
		SizeDistExisted = IR2L_GraphSizeDistributions()		

		//create graph and data for residual plot.
		ResidualsExisted = IR2L_GraphResiduals()
		
		//create graph and data for IQ4 vs Q plot.
		IQ4Existed = IR2L_GraphIQ4vsQ()
			
		//recolor as needed
		IR2L_SyncClrsAndSymbInGraphs()
		
		//and now we need to align them for user...
//		variable GraphSDExists, GraphResExists,GraphIQ4Exists
//		DoWIndow GraphSizeDistributions
//		GraphSDExists=V_Flag
//		if(V_Flag && !SizeDistExisted)
//			AutoPositionWindow/M=1 /R=LSQF_MainGraph GraphSizeDistributions
//		endif
//		
//		Dowindow LSQF_ResidualsGraph
//		GraphResExists=V_Flag
//		if(V_Flag && !ResidualsExisted)
//			if(GraphSDExists&& !SizeDistExisted)
//				AutoPositionWindow/M=1 /R=GraphSizeDistributions LSQF_ResidualsGraph
//			else
//				AutoPositionWindow/M=1 /R=LSQF_MainGraph LSQF_ResidualsGraph
//			endif
//		endif
//		
//		Dowindow LSQF_IQ4vsQGraph
//		GraphIQ4Exists=V_Flag
//		if(V_Flag && !IQ4Existed)
//				AutoPositionWindow/M=1 LSQF_IQ4vsQGraph
////			if(GraphResExists)
////				AutoPositionWindow/M=1 /R=LSQF_ResidualsGraph LSQF_IQ4vsQGraph
////			elseif(GraphSDExists)
////				AutoPositionWindow/M=1 /R=GraphSizeDistributions LSQF_IQ4vsQGraph
////			else
////				AutoPositionWindow/M=1 /R=LSQF_MainGraph LSQF_IQ4vsQGraph
////			endif
//		endif		
end

//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************

Function IR2L_SyncClrsAndSymbInGraphs()
	//syncs colors in graphs as much as possible

    String tnl = TraceNameList( "LSQF_MainGraph", ";", 1 )
    String info, tnlIQ4, tnlRes, tempName, tempNameIQ4, cmd, tempNameRes
    variable  k = ItemsInList(tnl)
    variable i, kIQ4, kRes
	DoWindow LSQF_MainGraph
	if(!V_Flag)		//no main graph, bail out
		return 0
	endif
	DoWIndow 	LSQF_IQ4vsQGraph
	if(V_Flag)
		tnlIQ4 = TraceNameList( "LSQF_IQ4vsQGraph", ";", 1 )
		kIQ4 = ItemsInList(tnlIQ4)
	endif
	DoWIndow 	LSQF_ResidualsGraph
	if(V_Flag)
		tnlRes = TraceNameList( "LSQF_ResidualsGraph", ";", 1 )
		kRes = ItemsInList(tnlRes)
	endif

      tnl = TraceNameList( "LSQF_MainGraph", ";", 1 )
      k = ItemsInList(tnl)
	
    if (k <= 1)
        return -1
    endif
    For(i=0;i<k;i+=1)
	    	tempName =  StringFromList(i, tnl , ";")
		info=TraceInfo("LSQF_MainGraph",tempName,0)
		if(StringMatch(tempName, "Intensity_set*" ))
			if(kIQ4>0)
				tempNameIQ4 = ReplaceString("Intensity_set" , tempName, "IntensityQ4_set")
				if(StringMatch(tnlIQ4, "*"+tempNameIQ4+";*" ))
					cmd = "ModifyGraph/W=LSQF_IQ4vsQGraph /Z rgb("+tempNameIQ4+")="+StringByKey("rgb(x)", info , "="  , ";")
					Execute(cmd)
					cmd = "ModifyGraph/W=LSQF_IQ4vsQGraph /Z marker("+tempNameIQ4+")="+StringByKey("marker(x)", info , "="  , ";")
					Execute(cmd)
				endif
			endif
			if(kRes>0)
				tempNameRes = ReplaceString("Intensity_set" , tempName, "Residuals_set")
				if(StringMatch(tnlRes, "*"+tempNameRes+";*" ))
					cmd = "ModifyGraph/W=LSQF_ResidualsGraph /Z rgb("+tempNameRes+")="+StringByKey("rgb(x)", info , "="  , ";")
					Execute(cmd)
					cmd = "ModifyGraph/W=LSQF_ResidualsGraph /Z marker("+tempNameRes+")="+StringByKey("marker(x)", info , "="  , ";")
					Execute(cmd)
				endif
			endif
		elseif(StringMatch(tempName, "IntensityModel_set*" ))
			if(kIQ4>0)
				tempNameIQ4 = ReplaceString("IntensityModel_set" , tempName, "IQ4Model_set")
				if(StringMatch(tnlIQ4, "*"+tempNameIQ4+";*" ))
					cmd = "ModifyGraph/W=LSQF_IQ4vsQGraph /Z rgb("+tempNameIQ4+")="+StringByKey("rgb(x)", info , "="  , ";")
					Execute(cmd)
					cmd = "ModifyGraph/W=LSQF_IQ4vsQGraph /Z marker("+tempNameIQ4+")="+StringByKey("marker(x)", info , "="  , ";")
					Execute(cmd)
				endif
			endif
	 	endif
    endfor
end
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
Function IR2L_GraphIQ4vsQ()

	string OldDf
	OldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF
	variable i, j, IQ4Existed
	//i is 1 - 6 populations
	//j is 1 - 10 data sets
	NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
	NVAR DisplayIQ4vsQplot=root:Packages:IR2L_NLSQF:DisplayIQ4vsQplot
	variable UseDatasw=1
	variable ModelExists=0
	IQ4Existed = 0

	if(!DisplayIQ4vsQplot)	
		//kill the plot and ignore the data
		DoWindow LSQF_IQ4vsQGraph
		if(V_Flag)
			KillWindow LSQF_IQ4vsQGraph
		endif
	else
		//need to create the data and plot them... 
		DoWindow LSQF_IQ4vsQGraph
		if(V_Flag)
			DoWindow/F LSQF_IQ4vsQGraph
			IQ4Existed = 1
		else
			Display /K=1/W=(313.5,424,858,624) as "LSQF2 IQ^4 vs Q graph"
			Dowindow/C LSQF_IQ4vsQGraph
		endif
	
		For(j=1;j<11;j+=1)
			NVAR UseTheData=$("root:Packages:IR2L_NLSQF:UseTheData_set"+num2str(j))
			UseDatasw=1
			if(!UseTheData || (!MultipleInputData && j>1))
				UseDatasw=0
			else	//create data
				Wave/Z DataQ = $("Q_set"+num2str(j))
				Wave/Z DataI=$("Intensity_set"+num2str(j))
				if(WaveExists(DataI) && WaveExists(DataQ))
					Duplicate/O DataI, $("IntensityQ4_set"+num2str(j))
					Wave/Z DataIQ4=$("IntensityQ4_set"+num2str(j))
					DataIQ4 = DataI * DataQ^4
				else
					Abort "Data are missing, report bug"
				endif
				Wave/Z ModelQ = $("Qmodel_set"+num2str(j))
				Wave/Z ModelI=$("IntensityModel_set"+num2str(j))
				if(WaveExists(ModelI) && WaveExists(ModelQ))
					ModelExists= 1
					Duplicate/O ModelI, $("IQ4Model_set"+num2str(j))
					Wave/Z ModelIQ4=$("IQ4Model_set"+num2str(j))
					ModelIQ4 = ModelI * ModelQ^4
				else
					ModelExists=0
				endif
			endif
			DoWIndow LSQF_IQ4vsQGraph
			if(!V_Flag)
				return  0 //no widnow open, do not bomb on user...
			endif
			//append data if needed
			CheckDisplayed/W=LSQF_IQ4vsQGraph $("IntensityQ4_set"+num2str(j))
			if(UseDatasw && V_Flag)
				//use the data and displayed, nothing to do
			elseif(UseDatasw && !V_Flag)
				//use the data and NOT displayed, append
				if(WaveExists(DataIQ4) && WaveExists(DataQ))
					AppendToGraph/W=LSQF_IQ4vsQGraph DataIQ4 vs DataQ
					ModifyGraph mode($("IntensityQ4_set"+num2str(j)))=3
					ModifyGraph zmrkSize($("IntensityQ4_set"+num2str(j)))={$("root:Packages:IR2L_NLSQF:IntensityMask_set"+num2str(j)),0,5,0.5,3}
					ModifyGraph marker($("IntensityQ4_set"+num2str(j)))=19
				endif
			elseif(!UseDataSw)
				//do not use these data
				RemoveFromGraph/Z/W=LSQF_IQ4vsQGraph $("IntensityQ4_set"+num2str(j))
			endif
			//append model if needed
			CheckDisplayed/W=LSQF_IQ4vsQGraph $("IQ4Model_set"+num2str(j))
			if(UseDatasw && V_Flag)
				//use the data and displayed, nothing to do
			elseif(UseDatasw && !V_Flag && ModelExists)
				//use the data and NOT displayed, append
				if(WaveExists(ModelIQ4) && WaveExists(ModelQ))
					AppendToGraph/W=LSQF_IQ4vsQGraph ModelIQ4 vs ModelQ
					ModifyGraph mode($("IQ4Model_set"+num2str(j)))=0
					ModifyGraph rgb($("IQ4Model_set"+num2str(j)))=(30583,30583,30583)
					ModifyGraph lsize($("IQ4Model_set"+num2str(j)))=2
				endif
			elseif(!UseDataSw)
				//do not use these data
				RemoveFromGraph/Z/W=LSQF_IQ4vsQGraph $("IQ4Model_set"+num2str(j))
			endif
		endfor
		GetAxis /W=LSQF_IQ4vsQGraph /Q bottom
		if(!V_Flag)
			//ModifyGraph/Z/W=LSQF_IQ4vsQGraph mode=3,marker=19,rgb=(0,0,0)
			ModifyGraph/Z/W=LSQF_IQ4vsQGraph log(bottom)=1
			ModifyGraph/Z/W=LSQF_IQ4vsQGraph grid=1,mirror=1
			Label/Z/W=LSQF_IQ4vsQGraph left "Intensity * Q^4"
			Label/Z/W=LSQF_IQ4vsQGraph bottom "Q [A\\S-1\\M]"
			ModifyGraph log=1
		endif
	endif
	setDataFolder OldDf	
	return IQ4Existed
end

//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
Function IR2L_GraphResiduals()

	string OldDf
	OldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF
	variable i, j, ResidualsExisted
	//i is 1 - 6 populations
	//j is 1 - 10 data sets
	NVAR MultipleInputData=root:Packages:IR2L_NLSQF:MultipleInputData
	NVAR DisplayResidualsPlot=root:Packages:IR2L_NLSQF:DisplayResidualsPlot
	variable UseDatasw=1
	ResidualsExisted = 0

	if(!DisplayResidualsPlot)
		DoWindow LSQF_ResidualsGraph
		if(V_Flag)
			KillWIndow LSQF_ResidualsGraph
		endif
		return 0
	endif


	DoWindow LSQF_ResidualsGraph
	if(V_Flag)
		DoWindow/F LSQF_ResidualsGraph
		ResidualsExisted = 1
	else
		Display /K=1/W=(313.5,304,858,504) as "LSQF2 residuals"
		Dowindow/C LSQF_ResidualsGraph
	endif

	For(j=1;j<11;j+=1)
		NVAR UseTheData=$("root:Packages:IR2L_NLSQF:UseTheData_set"+num2str(j))
		UseDatasw=1
		if(!UseTheData || (!MultipleInputData && j>1))
			UseDatasw=0
		endif
		//Wave/Z ModelQ = $("Qmodel_set"+num2str(j))
		Wave/Z ModelQ = $("Q_set"+num2str(j))
		Wave/Z Residuals=$("Residuals_set"+num2str(j))
		DoWIndow LSQF_ResidualsGraph
		if(!V_Flag)
			return  0 //no widnow open, do not bomb on user...
		endif
		CheckDisplayed/W=LSQF_ResidualsGraph $("Residuals_set"+num2str(j))
		if(UseDatasw && V_Flag)
			//use the data and displayed, nothing to do
		elseif(UseDatasw && !V_Flag)
			//use the data and NOT displayed, append
			if(WaveExists(Residuals) && WaveExists(ModelQ))
				AppendToGraph/W=LSQF_ResidualsGraph Residuals vs ModelQ
			endif
		elseif(!UseDataSw)
			//do not use these data
			RemoveFromGraph/Z/W=LSQF_ResidualsGraph $("Residuals_set"+num2str(j))
		endif
	endfor
	GetAxis /W=LSQF_ResidualsGraph /Q bottom
	if(!V_Flag)
		ModifyGraph/Z/W=LSQF_ResidualsGraph mode=3,marker=19,rgb=(0,0,0)
		ModifyGraph/Z/W=LSQF_ResidualsGraph log(bottom)=1
		ModifyGraph/Z/W=LSQF_ResidualsGraph grid=1,mirror=1
		Label/Z/W=LSQF_ResidualsGraph left "Normalized residual\r(Data - Model / Error)"
		Label/Z/W=LSQF_ResidualsGraph bottom "Q [A\\S-1\\M]"
	endif
	setDataFolder OldDf	
	return ResidualsExisted
end

//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************

//Calculate the distribution waves - depending on user selections

Function IR2L_CalculateDistributions(pop,Radius,NumDist,VolumeDist) //calculates both volume and number distributions and scales by volume
	variable pop
	wave Radius,NumDist,VolumeDist

	string oldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF
	NVAR UseNumberDistributions=root:Packages:IR2L_NLSQF:UseNumberDistributions
	
	SVAR DistShape=$("root:Packages:IR2L_NLSQF:PopSizeDistShape_pop"+num2str(pop))
	NVAR Volume=$("root:Packages:IR2L_NLSQF:Volume_Pop"+num2str(pop))
	//IR1_GaussProbability(x,location,scale, shape)
	NVAR LNMinSize=$("root:Packages:IR2L_NLSQF:LNMinSize_pop"+num2str(pop))
	NVAR LNMeanSize=$("root:Packages:IR2L_NLSQF:LNMeanSize_pop"+num2str(pop))
	NVAR LNSDeviation=$("root:Packages:IR2L_NLSQF:LNSdeviation_pop"+num2str(pop))
	NVAR GMeanSize=$("root:Packages:IR2L_NLSQF:GMeanSize_pop"+num2str(pop))
	NVAR GWidth=$("root:Packages:IR2L_NLSQF:GWidth_pop"+num2str(pop))
	NVAR SZMeanSize=$("root:Packages:IR2L_NLSQF:SZMeanSize_pop"+num2str(pop))
	NVAR SZWidth=$("root:Packages:IR2L_NLSQF:SZWidth_pop"+num2str(pop))
	NVAR LSWLocation=$("root:Packages:IR2L_NLSQF:LSWLocation_pop"+num2str(pop))
	Duplicate/Free VolumeDist, tempDist, TempVolDistL
	Redimension/D tempDist, TempVolDistL
	if(stringmatch(DistShape,"LogNormal"))
		tempDist = IR1_LogNormProbability(Radius[p],LNMinSize,LNMeanSize, LNSDeviation)
	elseif(stringmatch(DistShape,"Gauss"))
		tempDist = IR1_GaussProbability(Radius[p],GMeanSize,GWidth, 0)
	elseif(stringmatch(DistShape,"Schulz-Zimm"))
		tempDist = IR1_SchulzZimmProbability(Radius[p],SZMeanSize,SZWidth, 0)
	else
		tempDist = IR1_LSWProbability(Radius[p],LSWLocation,0, 0)
	endif
	NVAR DimensionIsDiameter = root:Packages:IR2L_NLSQF:SizeDist_DimensionIsDiameter
	if(DimensionIsDiameter) 				//all calculations above are done in radii, if we use Diameters, volume/number distributions needs to be half 
		Duplicate/Free Radius, tmpRadius
		tmpRadius = Radius/2
		IR2L_CalculateAveVolWave(TempVolDistL,tmpRadius,pop)
	else
		IR2L_CalculateAveVolWave(TempVolDistL,Radius,pop)
	endif		
	//calibrate - set volumes... 
	//This is for  number distributions
			//this is to calculate the number distribution, so the volume is right
			//the way we do this: integrate P(r)*V(r), get Ntotal as Vol/the integral calculated... 
			//and next multiply the number distribution by the total number of scatterers Ntotaql
//			Duplicate/O TempNumDist, temp_Calc_Wv
//			temp_Calc_Wv=TempNumDist*AveVolumeWave
//			variable Nt=DistVolFraction/areaXY(Distdiameters,temp_Calc_Wv,-inf,inf)	
//			TempNumDist*=Nt
	
	variable ScaleVol	
	if(UseNumberDistributions)
		NumDist=tempDist
		VolumeDist = TempVolDistL * NumDist
	else
		VolumeDist = tempDist
  		NumDist = VolumeDist /TempVolDistL	
	endif

	NVAR DimensionIsDiameter = root:Packages:IR2L_NLSQF:SizeDist_DimensionIsDiameter
	if(DimensionIsDiameter) 				//all calculations above are done in radii, if we use Diameters, volume/number distributions needs to be half 
		Duplicate/Free Radius, tmpRadius
		tmpRadius = Radius/2
		ScaleVol = Volume/areaXY(tmpRadius,VolumeDist,-inf,inf)
		VolumeDist = VolumeDist * ScaleVol
		NumDist = NumDist * ScaleVol
	else
		ScaleVol = Volume/areaXY(Radius,VolumeDist,-inf,inf)
		VolumeDist = VolumeDist * ScaleVol
		NumDist = NumDist * ScaleVol
	endif		

//	ScaleVol = Volume/areaXY(Radius,VolumeDist,-inf,inf)
//	VolumeDist = VolumeDist * ScaleVol
//	NumDist = NumDist * ScaleVol
	//KillWaves/Z TempVolDistL, tempDist
	setDataFolder OldDf
end
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
Function IR2L_CalculateAveVolWave(ResultsWave,Radius,pop) //calculates average volume wave for each bin
	variable pop
	wave ResultsWave, Radius

	string oldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF
	NVAR UseNumberDistributions=root:Packages:IR2L_NLSQF:UseNumberDistributions
	
	SVAR FormFactor=$("root:Packages:IR2L_NLSQF:FormFactor_pop"+num2str(pop))
	//IR1_GaussProbability(x,location,scale, shape)
	NVAR Param1=$("root:Packages:IR2L_NLSQF:FormFactor_Param1_pop"+num2str(pop))
	NVAR Param2=$("root:Packages:IR2L_NLSQF:FormFactor_Param2_pop"+num2str(pop))
	NVAR Param3=$("root:Packages:IR2L_NLSQF:FormFactor_Param3_pop"+num2str(pop))
	NVAR Param4=$("root:Packages:IR2L_NLSQF:FormFactor_Param4_pop"+num2str(pop))
	NVAR Param5=$("root:Packages:IR2L_NLSQF:FormFactor_Param5_pop"+num2str(pop))
	SVAR UserVolFnctFormula=$("root:Packages:IR2L_NLSQF:FFUserVolumeFormula_pop"+num2str(pop))
	//wave Radius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(pop))
	Duplicate/O Radius, tempDiameters
	redimension/D tempDiameters, Radius
	tempDiameters = 2 * Radius
 	IR1T_CreateAveVolumeWave(ResultsWave,tempDiameters,FormFactor,Param1,Param2,Param3,0,0,UserVolFnctFormula,Param1,Param2,Param3,Param4,Param5)	
	KillWaves/Z tempDiameters
	setDataFolder OldDf
end


//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************

//Calculate the distribution waves - depending on user selections
Function IR2L_CreateDistributionWaves(pop)
	variable pop
	
	string oldDf=GetDataFolder(1)
	setDataFolder root:Packages:IR2L_NLSQF
	SVAR FormFactor=$("root:Packages:IR2L_NLSQF:FormFactor_pop"+num2str(pop))
	SVAR Model=$("root:Packages:IR2L_NLSQF:Model_pop"+num2str(pop))	

//	string ThisDataFldrNm="NLSQF_Data"+num2str(pop)+"_Set"+num2str(dataSet)
//	NewDataFolder/O/S $(ThisDataFldrNm)
	NVAR RdistAuto=$("root:Packages:IR2L_NLSQF:RdistAuto_pop"+num2str(pop))
	NVAR RdistrSemiAuto=$("root:Packages:IR2L_NLSQF:RdistrSemiAuto_pop"+num2str(pop))
	NVAR RdistMan=$("root:Packages:IR2L_NLSQF:RdistMan_pop"+num2str(pop))
	NVAR RdistManMin=$("root:Packages:IR2L_NLSQF:RdistManMin_pop"+num2str(pop))
	NVAR RdistManMax=$("root:Packages:IR2L_NLSQF:RdistManMax_pop"+num2str(pop))
	NVAR RdistLog=$("root:Packages:IR2L_NLSQF:RdistLog_pop"+num2str(pop))
	NVAR RdistNumPnts=$("root:Packages:IR2L_NLSQF:RdistNumPnts_pop"+num2str(pop))
	NVAR RdistNeglectTails=$("root:Packages:IR2L_NLSQF:RdistNeglectTails_pop"+num2str(pop))
	SVAR PopSizeDistShape=$("root:Packages:IR2L_NLSQF:PopSizeDistShape_pop"+num2str(pop))
	NVAR DimensionIsDiameter = root:Packages:IR2L_NLSQF:SizeDist_DimensionIsDiameter

	if(stringmatch(PopSizeDistShape,"LogNormal"))
		NVAR location = $("root:Packages:IR2L_NLSQF:LNMinSize_pop"+num2str(pop))
		NVAR scale = $("root:Packages:IR2L_NLSQF:LNMeanSize_pop"+num2str(pop))
		NVAR shape = $("root:Packages:IR2L_NLSQF:LNSdeviation_pop"+num2str(pop))
	elseif(stringmatch(PopSizeDistShape,"Gauss"))
		NVAR location = $("root:Packages:IR2L_NLSQF:GMeanSize_pop"+num2str(pop))
		NVAR scale = $("root:Packages:IR2L_NLSQF:GWidth_pop"+num2str(pop))
		NVAR shape = $("root:Packages:IR2L_NLSQF:GWidth_pop"+num2str(pop))
	elseif(stringmatch(PopSizeDistShape,"Schulz-Zimm"))
		NVAR location = $("root:Packages:IR2L_NLSQF:SZMeanSize_pop"+num2str(pop))
		NVAR scale = $("root:Packages:IR2L_NLSQF:SZWidth_pop"+num2str(pop))
		NVAR shape = $("root:Packages:IR2L_NLSQF:SZWidth_pop"+num2str(pop))
	elseif(stringmatch(PopSizeDistShape,"LSW"))
		NVAR location = $("root:Packages:IR2L_NLSQF:LSWLocation_pop"+num2str(pop))
		NVAR scale = $("root:Packages:IR2L_NLSQF:GWidth_pop"+num2str(pop))
		NVAR shape = $("root:Packages:IR2L_NLSQF:GWidth_pop"+num2str(pop))
	endif

	if(stringMatch(Model,"Size Dist."))	 
		make/O/N=(RdistNumPnts) $("Radius_Pop"+num2str(pop)),$("Diameter_Pop"+num2str(pop)), $("VolumeDist_Pop"+num2str(pop)), $("NumberDist_Pop"+num2str(pop))
		Wave Radius=$("Radius_Pop"+num2str(pop))
		Wave Diameter=$("Diameter_Pop"+num2str(pop))
		if(DimensionIsDiameter)
			if(RdistMan)
				if(RdistLog)
					Diameter=10^(log(RdistManMin)+p*((log(RdistManMax)-log(RdistManMin))/(RdistNumPnts-1)))
				else
					Diameter=RdistManMin+p*(RdistManMax-RdistManMin)/(RdistNumPnts-1)
				endif
			elseif(RdistrSemiAuto)			//thsi is auto, but stopped when fitting... Needs to somehow pass to here that we are fitting... 
				IR2L_GenerateRadiiDist(PopSizeDistShape, Diameter, RdistNumPnts, RdistNeglectTails, location,scale, shape)
			else		//auto is default
				IR2L_GenerateRadiiDist(PopSizeDistShape, Diameter, RdistNumPnts, RdistNeglectTails, location,scale, shape)
			endif
			Radius = Diameter/2
		else			//use Radiii	
			if(RdistMan)
				if(RdistLog)
					Radius=10^(log(RdistManMin)+p*((log(RdistManMax)-log(RdistManMin))/(RdistNumPnts-1)))
				else
					Radius=RdistManMin+p*(RdistManMax-RdistManMin)/(RdistNumPnts-1)
				endif
			elseif(RdistrSemiAuto)			//thsi is auto, but stopped when fitting... Needs to somehow pass to here that we are fitting... 
				IR2L_GenerateRadiiDist(PopSizeDistShape, Radius, RdistNumPnts, RdistNeglectTails, location,scale, shape)
			else		//auto is default
				IR2L_GenerateRadiiDist(PopSizeDistShape, Radius, RdistNumPnts, RdistNeglectTails, location,scale, shape)
			endif
			Diameter = 2*Radius
		endif
	else
		make/O/N=(100) $("Radius_Pop"+num2str(pop)), $("VolumeDist_Pop"+num2str(pop)), $("NumberDist_Pop"+num2str(pop))
		Wave Radius=$("Radius_Pop"+num2str(pop))
		Radius=10+p*(990)/(99)
	endif

	setDataFolder OldDf	
end
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************


//****************   This calculates distribution of diameters and needed for the probability distribution   ***********************************************************

Function IR2L_GenerateRadiiDist(MyFunction, OutputWave, numberOfPoints, myprecision, location,scale, shape)
	string MyFunction
	wave OutputWave
	variable numberOfPoints, myprecision, location,scale, shape
	//
	//  Important : this wave will be produced in current folder
	//
	//this function generates non-regular distribution of diameters for distributions
	//Myfunction can now be Gauss, LogNormal, LSW, or LogNormal
	//OutputWaveName is string with wave name. The wave is created with numberOfPoints number of points and existing one, if exists, is overwritten
	// my precision is value (~0.001 for example) which denotes how low probability we want to neglect (P<precision and P>(1-precision) are neglected
	//location, scale, shape are values for the probability distributions
	
	//logic: we start in the median and walk towards low (high) values. When cumulative value is smaller (larger) than precision (1-precision)
	//we end. If we walk out of reasonable values (10A and 10^15A), we stop.
	
	//first we need to find step, which we will use to step from median
	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:IR2L_NLSQF


	variable startx, endx, guess, Step, mode, tempVal, tempResult
	
	if (cmpstr("Gauss",MyFunction)==0)
		Step=scale*0.02					//standard deviation
	endif
	if (cmpstr("Schulz-Zimm",MyFunction)==0)
		Step=scale*0.02					//standard deviation
	endif
	if (cmpstr("LSW",MyFunction)==0)
		Step=location*0.3				//just some step for this distribution
	endif
	if (cmpstr("LogNormal",MyFunction)==0)
		Step=4*sqrt(exp(shape^2)*(exp(shape^2)-1))	//standard deviation
	endif
	if (cmpstr("PowerLaw",MyFunction)==0)
		Step=500	//a number here
	endif
	
	//now we need to find the median

	if (cmpstr("Gauss",MyFunction)==0)
		mode=location	//=median
	endif
	if (cmpstr("Schulz-Zimm",MyFunction)==0)
		mode=location	//=median
	endif
	if (cmpstr("LSW",MyFunction)==0)
		mode=location	//close to median, who really cares where we start as long as it is close...
	endif
	if (cmpstr("LogNormal",MyFunction)==0)
		mode=location+scale/(exp(shape^2))	//=median
	endif
	if (cmpstr("PowerLaw",MyFunction)==0)
		mode=500  				// a number
	endif
	// look for minimum
	//now we can start at median and go step by step and end when the 
	//cumulative function is smaller than the myprecision
	
	variable minimumXPossible=1   //if it should be smaller than 2A, it is nonsence...
	
	tempVal=mode
	
	do
		tempVal=tempVal-Step			//OK, this way we should make always one more step over the limit...

		if (tempVal<minimumXPossible)
			tempVal=minimumXPossible
		endif

		if (cmpstr("Gauss",MyFunction)==0)
			tempResult=IR1_GaussCumulative(tempVal,location,scale, shape)
		endif
		if (cmpstr("Schulz-Zimm",MyFunction)==0)
			tempResult=IR1_SZCumulative(tempVal,location,scale, shape)
		endif
		if (cmpstr("LSW",MyFunction)==0)
			tempResult=IR2L_LSWCumulative(tempVal,location,scale, shape)
		endif
		if (cmpstr("LogNormal",MyFunction)==0)
			tempResult=IR1_LogNormCumulative(tempVal,location,scale, shape)
		endif
		if (cmpstr("PowerLaw",MyFunction)==0)		//this funny function exists over whole size range possible....
			tempResult=0
			tempVal=minimumXPossible
		endif
		
	while ((tempResult>myprecision)&&(tempVal>minimumXPossible))			

	startx = tempVal
	//and this will be needed lower, in case when we have distributions attempting to get into negative diameters...
	variable startCumTrgts=myprecision
	if (startx==minimumXPossible)	//in this case we run into negative values and overwrote the startX values
			if (cmpstr("Gauss",MyFunction)==0)
				startCumTrgts=IR1_GaussCumulative(minimumXPossible,location,scale, shape)
			endif
			if (cmpstr("Schulz-Zimm",MyFunction)==0)		
				startCumTrgts=IR1_SZCumulative(minimumXPossible,location,scale, shape)
			endif
			if (cmpstr("LSW",MyFunction)==0)
				startCumTrgts=IR2L_LSWCumulative(minimumXPossible,location,scale, shape)
			endif
			if (cmpstr("LogNormal",MyFunction)==0)
				startCumTrgts=IR1_LogNormCumulative(minimumXPossible,location,scale, shape)
			endif
			if (cmpstr("PowerLaw",MyFunction)==0)
				startCumTrgts=myprecision
			endif
	endif

	//now we need to calculate the endx

	variable maximumXPossible=1e15	//maximum, fixed for giant number due to use of the code for light scattering
		
	tempVal=mode
	
	do
		tempVal=tempVal+Step		//again, whould be one step larger than needed...
		if (tempVal>maximumXPossible)
			tempVal=maximumXPossible
		endif

		if (cmpstr("Gauss",MyFunction)==0)
			tempResult=IR1_GaussCumulative(tempVal,location,scale, shape)
		endif
		if (cmpstr("Schulz-Zimm",MyFunction)==0)
			tempResult=IR1_SZCumulative(tempVal,location,scale, shape)
		endif
		if (cmpstr("LSW",MyFunction)==0)
			tempResult = 1
			tempVal = 1.5 * location //this distribution does not exist over this value...
		endif
		if (cmpstr("LogNormal",MyFunction)==0)
			tempResult=IR1_LogNormCumulative(tempVal,location,scale, shape)
		endif
		if (cmpstr("PowerLaw",MyFunction)==0)
			maximumXPossible=1e7
			tempResult=1
			tempVal=maximumXPossible
		endif

	while ((tempResult<(1-myprecision))&&(tempVal<maximumXPossible))			
	
	endx = tempVal

	//and now we can start making the the data. 
	// First we will create a wave with equally distributed values between myprecision and 1-myprecision : Temp_CumulTargets
	//We will also create waves with 3*as many points with diameters between startx and endx (Temp_diameters) and with appropriate cumulative distribution (Temp_CumulativeWave)
	//then we will look for which diameters we get the cumulative numbers in Temp_CumulTargets and put these in output wave
	
	Make/D /N=(numberOfPoints) /O Temp_CumulTargets
	Make/D /N=(3*numberOfPoints) /O Temp_CumulativeWave,Temp_diameters
	
	
	Temp_diameters=startx+p*(endx-startx)/(3*numberOfPoints-1)			//this puts the proper diameters distribution in the temp diameters wave
	
	Temp_CumulTargets=startCumTrgts+p*(1-myprecision-startCumTrgts)/(numberOfPoints-1) //this puts equally spaced values between myprecision and (1-myprecision) in this wave
	
	//calculate the cumulative waves
	if (cmpstr("Gauss",MyFunction)==0)
		Temp_CumulativeWave=IR1_GaussCumulative(Temp_diameters,location,scale, shape)
	endif
	if (cmpstr("Schulz-Zimm",MyFunction)==0)
		Temp_CumulativeWave=IR1_SZCumulative(Temp_diameters,location,scale, shape)
	endif
	if (cmpstr("LSW",MyFunction)==0)
		Temp_CumulativeWave=IR2L_LSWCumulative(Temp_diameters,location,scale, shape)
		Temp_CumulativeWave[numpnts(Temp_CumulativeWave)-1]=1	//last point is NaN, we need to make it 1
	endif
	if (cmpstr("LogNormal",MyFunction)==0)
		Temp_CumulativeWave=IR1_LogNormCumulative(Temp_diameters,location,scale, shape)
	endif
	if (cmpstr("PowerLaw",MyFunction)==0)
		Temp_CumulativeWave=IR1_PowerLawCumulative(Temp_diameters,shape,startx,endx)
	endif
	
		//and now the difficult part - get the diameterss, which are unequally spaced, but whose probability for the distribution are equally spaced...
		OutputWave=interp(Temp_CumulTargets, Temp_CumulativeWave, Temp_diameters )
	variable temp
	if (cmpstr("PowerLaw",MyFunction)==0) //the code above fails for this distribution type, we need to create new diameters...
		//DistributionDiametersWave=startx+log(p)*(endx-startx)/log(numberOfPoints)
		//temp=log(startx)+p*((log(endx)-log(startx))/(numberOfPoints-1))
		OutputWave=10^(log(startx)+p*((log(endx)-log(startx))/(numberOfPoints-1)))
	endif

	
	//and now cleanup
	
	KillWaves/Z Temp_CumulTargets //, myTest
	KillWaves/Z Temp_CumulativeWave,Temp_diameters

	setDataFolder OldDf
	
end



//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
Function IR2L_LSWCumulative(xx,location,scale, shape)
		variable xx, location,scale, shape
	//this function calculates probability for LSW distribution
	//I do not have cumulative probability function, so it is done numerically... More complex and much more annoying...
	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:IR2L_NLSQF
			
	variable result, pointsNeeded=ceil(xx/30+30)
	//points neede is at least 30 and max out around 370 for 10000 A location
	make/D /O/N=(PointsNeeded) temp_LSWwav 
	
	SetScale/P x 10,(xx/(numpnts(temp_LSWwav)-3)),"", temp_LSWwav	
	//this sets scale so the model wave x scale covers area from 10 A over the needed point...
	
	temp_LSWwav=IR1_LSWProbability(pnt2x(temp_LSWwav, p ),location,scale, shape)
	
	integrate /T temp_LSWwav
	//and at this point the temp_LSWwav has integral values in it... 
	result = temp_LSWwav(xx) //here we get the value interpolated (linearly) for the needed point...
	KillWaves/Z temp_LSWwav
	setDataFolder OldDf
	return result
end


//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
Function IR2L_UpdateModeMedianMean()

	NVAR UseNumberDistributions=root:Packages:IR2L_NLSQF:UseNumberDistributions
	
	variable i
	For (i=1;i<11;i+=1)
		NVAR UsePop=$("root:Packages:IR2L_NLSQF:UseThePop_pop"+num2str(i))
		if(UsePop)
			IR2L_UpdtSeparateMMM(i)
		endif	
	endfor
end
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************


Function IR2L_UpdtSeparateMMM(distNum)
	Variable distNum

	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:IR2L_NLSQF
	SVAR FormFactor=$("root:Packages:IR2L_NLSQF:FormFactor_pop"+num2str(distNum))

	NVAR DistMean=$("root:Packages:IR2L_NLSQF:Mean_pop"+num2str(distNum))
	NVAR DistMedian=$("root:Packages:IR2L_NLSQF:Median_pop"+num2str(distNum))
	NVAR DistMode=$("root:Packages:IR2L_NLSQF:Mode_pop"+num2str(distNum))
	NVAR DistFWHM=$("root:Packages:IR2L_NLSQF:FWHM_pop"+num2str(distNum))
	NVAR DistInputNumberDist=root:Packages:IR2L_NLSQF:UseNumberDistributions

	Wave DistRadius=$("root:Packages:IR2L_NLSQF:Radius_Pop"+num2str(distNum))
	Wave DistVolumeDist=$("root:Packages:IR2L_NLSQF:VolumeDist_Pop"+num2str(distNum))
	Wave DistNumberDist=$("root:Packages:IR2L_NLSQF:NumberDist_Pop"+num2str(distNum))
	
	if(stringMatch(FormFactor,"Unified_Level"))
		DistMean=NaN
		DistMedian=NaN
		DistMode=NaN
		DistFWHM=NaN
	else
		//root:Packages:IR2L_NLSQF:NumberDist_Dist1,root:Packages:IR2L_NLSQF:VolumeDist_Dist1,root:Packages:IR2L_NLSQF:Radius_Dist1	
		if (DistInputNumberDist)		//use number distribution...
			Duplicate/O DistNumberDist, Temp_Probability, Another_temp, Temp_Cumulative
			Redimension/D  Temp_Probability, Another_temp, Temp_Cumulative
			Temp_Cumulative=areaXY(DistRadius, Temp_Probability, DistRadius[0], DistRadius[p] )
		else							//use volume distribution
			Duplicate/O DistVolumeDist, Temp_Probability, Another_temp, Temp_Cumulative
			Redimension/D  Temp_Probability, Another_temp, Temp_Cumulative
			Temp_Cumulative=areaXY(DistRadius, Temp_Probability, DistRadius[0], DistRadius[p] )
		endif	
	
		
			Another_temp=DistRadius*Temp_Probability
			DistMean=areaXY(DistRadius, Another_temp,0,inf)	/ areaXY(DistRadius, Temp_Probability,0,inf)				//Sum P(D)*D*deltaD/P(D)*deltaD
			DistMedian=DistRadius[BinarySearchInterp(Temp_Cumulative, 0.5*Temp_Cumulative[numpnts(Temp_Cumulative)-1] )]		//R for which cumulative probability=0.5
			FindPeak/P/Q Temp_Probability
			DistMode=DistRadius[V_PeakLoc]								//location of maximum on the P(R)
			
			DistFWHM=IR1_FindFWHM(Temp_Probability,DistRadius)				//Ok, this is monkey approach
	endif	
	
	KillWaves/Z Temp_Probability, Temp_Cumulative, Another_Temp

	setDataFolder OldDf
end


//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
